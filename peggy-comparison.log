BENCHMARKING uninlined-spec/scimark/
LU
Command timed out
java -Xmx2000m -cp .:peggy_1.0.jar:uninlined-spec/scimark/ peggy.optimize.java.Main -O2 LU -activate livsr:binop:constant -glpkPath "/glpk-5.0/examples/glpsol" -pb glpk -axioms axioms/java_arithmetic_axioms.xml:axioms/java_operator_axioms.xml:axioms/java_operator_costs.xml:axioms/java_util_axioms.xml -tmpFolder tmp
PEGGY OUTPUT:
b'+ Successfully added axiom file: axioms/java_operator_axioms.xml
+ Successfully added axiom file: axioms/java_util_axioms.xml
+ Successfully added axiom file: axioms/java_operator_costs.xml
+ Successfully added axiom file: axioms/java_arithmetic_axioms.xml
+ Loading class file LU
+ Optimizing class LU
   - Processing method <LU: void <init>(int)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 14 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 14
GLPKFormulation: Number of values: 14
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <LU: void <init>(int)> SUCCESSFUL
      * Optimization took 322
      * PEG2PEGTIME 238
      * PBTIME 160
      * ENGINETIME 6
      * Optimization ratio 2100/2100 = 1.0
      * PEG-based Optimization ratio 2100/2100 = 1.0
   - Done processing method <LU: void <init>(int)>
   - Processing method <LU: void main(int)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 18 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 18
GLPKFormulation: Number of values: 18
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <LU: void main(int)> SUCCESSFUL
      * Optimization took 185
      * PEG2PEGTIME 173
      * PBTIME 141
      * ENGINETIME 3
      * Optimization ratio 6000/6000 = 1.0
      * PEG-based Optimization ratio 6000/6000 = 1.0
   - Done processing method <LU: void main(int)>
   - Processing method <LU: double num_flops(int)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 16 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 16
GLPKFormulation: Number of values: 13
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <LU: double num_flops(int)> SUCCESSFUL
      * Optimization took 195
      * PEG2PEGTIME 184
      * PBTIME 139
      * ENGINETIME 13
      * Optimization ratio 120/120 = 1.0
      * PEG-based Optimization ratio 120/120 = 1.0
   - Done processing method <LU: double num_flops(int)>
   - Processing method <LU: double[] new_copy(double[])>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine reached iteration bound of 1000 after 516 milliseconds
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 1358
GLPKFormulation: Number of values: 987
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <LU: double[] new_copy(double[])> SUCCESSFUL
      * Optimization took 2424
      * PEG2PEGTIME 2382
      * PBTIME 1839
      * ENGINETIME 516
      * Optimization ratio 3350/3350 = 1.0
      * PEG-based Optimization ratio 3350/3350 = 1.0
   - Done processing method <LU: double[] new_copy(double[])>
   - Processing method <LU: double[][] new_copy(double[][])>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine reached iteration bound of 1000 after 365 milliseconds
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 1124
GLPKFormulation: Number of values: 1412
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <LU: double[][] new_copy(double[][])> SUCCESSFUL
      * Optimization took 2407
      * PEG2PEGTIME 2350
      * PBTIME 1968
      * ENGINETIME 365
      * Optimization ratio 26410/26410 = 1.0
      * PEG-based Optimization ratio 26410/26410 = 1.0
   - Done processing method <LU: double[][] new_copy(double[][])>
   - Processing method <LU: int[] new_copy(int[])>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine reached iteration bound of 1000 after 207 milliseconds
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 1358
GLPKFormulation: Number of values: 986
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <LU: int[] new_copy(int[])> SUCCESSFUL
      * Optimization took 2082
      * PEG2PEGTIME 2059
      * PBTIME 1838
      * ENGINETIME 207
      * Optimization ratio 3350/3350 = 1.0
      * PEG-based Optimization ratio 3350/3350 = 1.0
   - Done processing method <LU: int[] new_copy(int[])>
   - Processing method <LU: void insert_copy(double[][],double[][])>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine reached iteration bound of 1000 after 243 milliseconds
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 840
GLPKFormulation: Number of values: 1875
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <LU: void insert_copy(double[][],double[][])> SUCCESSFUL
      * Optimization took 12826
      * PEG2PEGTIME 12747
      * PBTIME 12486
      * ENGINETIME 243
      * Optimization ratio 109514/109514 = 1.0
      * PEG-based Optimization ratio 109514/109514 = 1.0
   - Done processing method <LU: void insert_copy(double[][],double[][])>
   - Processing method <LU: double[][] getLU()>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 14 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 14
GLPKFormulation: Number of values: 14
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <LU: double[][] getLU()> SUCCESSFUL
      * Optimization took 179
      * PEG2PEGTIME 173
      * PBTIME 160
      * ENGINETIME 0
      * Optimization ratio 2100/2100 = 1.0
      * PEG-based Optimization ratio 2100/2100 = 1.0
   - Done processing method <LU: double[][] getLU()>
   - Processing method <LU: int[] getPivot()>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 14 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 14
GLPKFormulation: Number of values: 14
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <LU: int[] getPivot()> SUCCESSFUL
      * Optimization took 199
      * PEG2PEGTIME 193
      * PBTIME 164
      * ENGINETIME 1
      * Optimization ratio 2100/2100 = 1.0
      * PEG-based Optimization ratio 2100/2100 = 1.0
   - Done processing method <LU: int[] getPivot()>
   - Processing method <LU: double[] solve(double[])>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 23 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 23
GLPKFormulation: Number of values: 23
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <LU: double[] solve(double[])> SUCCESSFUL
      * Optimization took 203
      * PEG2PEGTIME 195
      * PBTIME 167
      * ENGINETIME 1
      * Optimization ratio 5200/5200 = 1.0
      * PEG-based Optimization ratio 5200/5200 = 1.0
   - Done processing method <LU: double[] solve(double[])>
   - Processing method <LU: int factor(double[][],int[])>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine reached iteration bound of 1000 after 224 milliseconds
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 809
GLPKFormulation: Number of values: 2104
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      ! Error processing method <LU: int factor(double[][],int[])> [
         java.lang.StackOverflowError
         \tat util.integer.Bit32IntSet.<init>(Bit32IntSet.java:14)
         \tat util.integer.IntCollections.createBoundedBitSet(IntCollections.java:460)
         \tat eqsat.revert.Block$19.get(Block.java:1125)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         \tat eqsat.revert.Block$19.get(Block.java:1129)
         
      ]
      * Reverting to original method body
      * Optimization of method <LU: int factor(double[][],int[])> FAILED
   - Processing method <LU: void solve(double[][],int[],double[])>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine reached iteration bound of 1000 after 204 milliseconds
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 995
GLPKFormulation: Number of values: 1621
         @ Running solver
'
END PEGGY OUTPUT
Random
Command failed
java -Xmx2000m -cp .:peggy_1.0.jar:uninlined-spec/scimark/ peggy.optimize.java.Main -O2 Random -activate livsr:binop:constant -glpkPath "/glpk-5.0/examples/glpsol" -pb glpk -axioms axioms/java_arithmetic_axioms.xml:axioms/java_operator_axioms.xml:axioms/java_operator_costs.xml:axioms/java_util_axioms.xml -tmpFolder tmp
PEGGY OUTPUT:
b'+ Successfully added axiom file: axioms/java_operator_axioms.xml
+ Successfully added axiom file: axioms/java_util_axioms.xml
+ Successfully added axiom file: axioms/java_operator_costs.xml
+ Successfully added axiom file: axioms/java_arithmetic_axioms.xml
+ Loading class file Random
+ Optimizing class Random
   - Processing method <Random: void <init>()>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 50 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 50
GLPKFormulation: Number of values: 50
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <Random: void <init>()> SUCCESSFUL
      * Optimization took 357
      * PEG2PEGTIME 268
      * PBTIME 181
      * ENGINETIME 15
      * Optimization ratio 6820/6820 = 1.0
      * PEG-based Optimization ratio 6820/6820 = 1.0
   - Done processing method <Random: void <init>()>
   - Processing method <Random: void <init>(double,double)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 62 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 62
GLPKFormulation: Number of values: 62
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <Random: void <init>(double,double)> SUCCESSFUL
      * Optimization took 240
      * PEG2PEGTIME 212
      * PBTIME 166
      * ENGINETIME 14
      * Optimization ratio 7224/7224 = 1.0
      * PEG-based Optimization ratio 7224/7224 = 1.0
   - Done processing method <Random: void <init>(double,double)>
   - Processing method <Random: void <init>(int)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 45 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 45
GLPKFormulation: Number of values: 45
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <Random: void <init>(int)> SUCCESSFUL
      * Optimization took 201
      * PEG2PEGTIME 183
      * PBTIME 151
      * ENGINETIME 8
      * Optimization ratio 4800/4800 = 1.0
      * PEG-based Optimization ratio 4800/4800 = 1.0
   - Done processing method <Random: void <init>(int)>
   - Processing method <Random: void <init>(int,double,double)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 57 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 57
GLPKFormulation: Number of values: 57
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <Random: void <init>(int,double,double)> SUCCESSFUL
      * Optimization took 219
      * PEG2PEGTIME 191
      * PBTIME 157
      * ENGINETIME 10
      * Optimization ratio 5204/5204 = 1.0
      * PEG-based Optimization ratio 5204/5204 = 1.0
   - Done processing method <Random: void <init>(int,double,double)>
   - Processing method <Random: double nextDouble()>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 104 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 104
GLPKFormulation: Number of values: 97
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <Random: double nextDouble()> SUCCESSFUL
      * Optimization took 318
      * PEG2PEGTIME 232
      * PBTIME 174
      * ENGINETIME 31
      * Optimization ratio 2320/2320 = 1.0
      * PEG-based Optimization ratio 2320/2320 = 1.0
   - Done processing method <Random: double nextDouble()>
   - Processing method <Random: void nextDoubles(double[])>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine reached iteration bound of 1000 after 443 milliseconds
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 790
GLPKFormulation: Number of values: 981
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <Random: void nextDoubles(double[])> SUCCESSFUL
      * Optimization took 2957
      * PEG2PEGTIME 2378
      * PBTIME 1898
      * ENGINETIME 443
Exception in thread "main" java.lang.NullPointerException
\tat peggy.analysis.PEGCostCalculator.assignVariance(PEGCostCalculator.java:39)
\tat peggy.analysis.PEGCostCalculator.cost(PEGCostCalculator.java:91)
\tat peggy.optimize.java.Main.calculatePEGCost(Main.java:2348)
\tat peggy.optimize.java.Main.optimizeAll(Main.java:906)
\tat peggy.optimize.java.Main.optimizeClass(Main.java:704)
\tat peggy.optimize.java.Main.main(Main.java:2881)
'
END PEGGY OUTPUT
SparseCompRow
PEGGY OUTPUT:
b'+ Successfully added axiom file: axioms/java_operator_axioms.xml
+ Successfully added axiom file: axioms/java_util_axioms.xml
+ Successfully added axiom file: axioms/java_operator_costs.xml
+ Successfully added axiom file: axioms/java_arithmetic_axioms.xml
+ Loading class file SparseCompRow
+ Optimizing class SparseCompRow
   - Processing method <SparseCompRow: void <init>(int)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 14 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 14
GLPKFormulation: Number of values: 14
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <SparseCompRow: void <init>(int)> SUCCESSFUL
      * Optimization took 289
      * PEG2PEGTIME 231
      * PBTIME 156
      * ENGINETIME 5
      * Optimization ratio 2100/2100 = 1.0
      * PEG-based Optimization ratio 2100/2100 = 1.0
   - Done processing method <SparseCompRow: void <init>(int)>
   - Processing method <SparseCompRow: void main(int)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 18 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 18
GLPKFormulation: Number of values: 18
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <SparseCompRow: void main(int)> SUCCESSFUL
      * Optimization took 178
      * PEG2PEGTIME 170
      * PBTIME 138
      * ENGINETIME 3
      * Optimization ratio 6000/6000 = 1.0
      * PEG-based Optimization ratio 6000/6000 = 1.0
   - Done processing method <SparseCompRow: void main(int)>
   - Processing method <SparseCompRow: double num_flops(int,int,int)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 18 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 18
GLPKFormulation: Number of values: 15
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <SparseCompRow: double num_flops(int,int,int)> SUCCESSFUL
      * Optimization took 186
      * PEG2PEGTIME 172
      * PBTIME 139
      * ENGINETIME 12
      * Optimization ratio 140/140 = 1.0
      * PEG-based Optimization ratio 140/140 = 1.0
   - Done processing method <SparseCompRow: double num_flops(int,int,int)>
   - Processing method <SparseCompRow: void matmult(double[],double[],int[],int[],double[],int,int)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine reached iteration bound of 1000 after 550 milliseconds
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 925
GLPKFormulation: Number of values: 1282
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <SparseCompRow: void matmult(double[],double[],int[],int[],double[],int,int)> SUCCESSFUL
      * Optimization took 17676
      * PEG2PEGTIME 17501
      * PBTIME 16920
      * ENGINETIME 551
      * Optimization ratio 412349/412349 = 1.0
      * PEG-based Optimization ratio 412349/412349 = 1.0
   - Done processing method <SparseCompRow: void matmult(double[],double[],int[],int[],double[],int,int)>
   - Processing method <SparseCompRow: double measureSparseMatmult(int,int,double,Random)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine reached iteration bound of 1000 after 415 milliseconds
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 1664
GLPKFormulation: Number of values: 1757
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <SparseCompRow: double measureSparseMatmult(int,int,double,Random)> SUCCESSFUL
      * Optimization took 195515
      * PEG2PEGTIME 195457
      * PBTIME 195025
      * ENGINETIME 415
      * Optimization ratio 42704/43304 = 0.9861444670238315
      * PEG-based Optimization ratio 42704/43304 = 0.9861444670238315
   - Done processing method <SparseCompRow: double measureSparseMatmult(int,int,double,Random)>
   - Processing method <SparseCompRow: void run()>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 28 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 28
GLPKFormulation: Number of values: 28
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <SparseCompRow: void run()> SUCCESSFUL
      * Optimization took 178
      * PEG2PEGTIME 171
      * PBTIME 156
      * ENGINETIME 1
      * Optimization ratio 6200/6200 = 1.0
      * PEG-based Optimization ratio 6200/6200 = 1.0
   - Done processing method <SparseCompRow: void run()>
+ Done optimizing SparseCompRow
+ Final results:
   - Skipped methods = 0
   - Buggy methods = 0
   - Total methods = 6
+ Fixing bytecode of method <SparseCompRow: void <init>(int)>
+ Fixing bytecode of method <SparseCompRow: void main(int)>
+ Fixing bytecode of method <SparseCompRow: double num_flops(int,int,int)>
+ Fixing bytecode of method <SparseCompRow: void matmult(double[],double[],int[],int[],double[],int,int)>
+ Fixing bytecode of method <SparseCompRow: double measureSparseMatmult(int,int,double,Random)>
+ Fixing bytecode of method <SparseCompRow: void run()>
+ Writing class back to optimized/SparseCompRow.class
+ Total optimization time = 214554 milliseconds
'
END PEGGY OUTPUT
SOR
Command timed out
java -Xmx2000m -cp .:peggy_1.0.jar:uninlined-spec/scimark/ peggy.optimize.java.Main -O2 SOR -activate livsr:binop:constant -glpkPath "/glpk-5.0/examples/glpsol" -pb glpk -axioms axioms/java_arithmetic_axioms.xml:axioms/java_operator_axioms.xml:axioms/java_operator_costs.xml:axioms/java_util_axioms.xml -tmpFolder tmp
PEGGY OUTPUT:
b'+ Successfully added axiom file: axioms/java_operator_axioms.xml
+ Successfully added axiom file: axioms/java_util_axioms.xml
+ Successfully added axiom file: axioms/java_operator_costs.xml
+ Successfully added axiom file: axioms/java_arithmetic_axioms.xml
+ Loading class file SOR
+ Optimizing class SOR
   - Processing method <SOR: void <init>(int)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 14 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 14
GLPKFormulation: Number of values: 14
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <SOR: void <init>(int)> SUCCESSFUL
      * Optimization took 326
      * PEG2PEGTIME 241
      * PBTIME 160
      * ENGINETIME 5
      * Optimization ratio 2100/2100 = 1.0
      * PEG-based Optimization ratio 2100/2100 = 1.0
   - Done processing method <SOR: void <init>(int)>
   - Processing method <SOR: void main(int)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 18 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 18
GLPKFormulation: Number of values: 18
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <SOR: void main(int)> SUCCESSFUL
      * Optimization took 184
      * PEG2PEGTIME 172
      * PBTIME 140
      * ENGINETIME 4
      * Optimization ratio 6000/6000 = 1.0
      * PEG-based Optimization ratio 6000/6000 = 1.0
   - Done processing method <SOR: void main(int)>
   - Processing method <SOR: double num_flops(int,int,int)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 360 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 315
GLPKFormulation: Number of values: 87
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <SOR: double num_flops(int,int,int)> SUCCESSFUL
      * Optimization took 3280
      * PEG2PEGTIME 3265
      * PBTIME 2960
      * ENGINETIME 277
      * Optimization ratio 128/128 = 1.0
      * PEG-based Optimization ratio 128/128 = 1.0
   - Done processing method <SOR: double num_flops(int,int,int)>
   - Processing method <SOR: double execute(double,double[][],int)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine reached iteration bound of 1000 after 507 milliseconds
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 1463
GLPKFormulation: Number of values: 2145
         @ Running solver
'
END PEGGY OUTPUT
MonteCarlo
PEGGY OUTPUT:
b'+ Successfully added axiom file: axioms/java_operator_axioms.xml
+ Successfully added axiom file: axioms/java_util_axioms.xml
+ Successfully added axiom file: axioms/java_operator_costs.xml
+ Successfully added axiom file: axioms/java_arithmetic_axioms.xml
+ Loading class file MonteCarlo
+ Optimizing class MonteCarlo
   - Processing method <MonteCarlo: void <init>()>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 10 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 10
GLPKFormulation: Number of values: 10
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <MonteCarlo: void <init>()> SUCCESSFUL
      * Optimization took 307
      * PEG2PEGTIME 225
      * PBTIME 152
      * ENGINETIME 4
      * Optimization ratio 2000/2000 = 1.0
      * PEG-based Optimization ratio 2000/2000 = 1.0
   - Done processing method <MonteCarlo: void <init>()>
   - Processing method <MonteCarlo: void main()>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 16 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 16
GLPKFormulation: Number of values: 16
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <MonteCarlo: void main()> SUCCESSFUL
      * Optimization took 173
      * PEG2PEGTIME 167
      * PBTIME 137
      * ENGINETIME 3
      * Optimization ratio 6000/6000 = 1.0
      * PEG-based Optimization ratio 6000/6000 = 1.0
   - Done processing method <MonteCarlo: void main()>
   - Processing method <MonteCarlo: double num_flops(int)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 10 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 10
GLPKFormulation: Number of values: 9
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <MonteCarlo: double num_flops(int)> SUCCESSFUL
      * Optimization took 167
      * PEG2PEGTIME 158
      * PBTIME 129
      * ENGINETIME 8
      * Optimization ratio 40/40 = 1.0
      * PEG-based Optimization ratio 40/40 = 1.0
   - Done processing method <MonteCarlo: double num_flops(int)>
   - Processing method <MonteCarlo: double integrate(int)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine reached iteration bound of 1000 after 583 milliseconds
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 740
GLPKFormulation: Number of values: 1024
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <MonteCarlo: double integrate(int)> SUCCESSFUL
      * Optimization took 2830
      * PEG2PEGTIME 2753
      * PBTIME 2144
      * ENGINETIME 583
      * Optimization ratio 64420/64420 = 1.0
      * PEG-based Optimization ratio 64420/64420 = 1.0
   - Done processing method <MonteCarlo: double integrate(int)>
   - Processing method <MonteCarlo: double measureMonteCarlo(double,Random)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 45 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 45
GLPKFormulation: Number of values: 44
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <MonteCarlo: double measureMonteCarlo(double,Random)> SUCCESSFUL
      * Optimization took 195
      * PEG2PEGTIME 173
      * PBTIME 155
      * ENGINETIME 2
      * Optimization ratio 21160/21160 = 1.0
      * PEG-based Optimization ratio 21160/21160 = 1.0
   - Done processing method <MonteCarlo: double measureMonteCarlo(double,Random)>
   - Processing method <MonteCarlo: void run()>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 20 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 20
GLPKFormulation: Number of values: 20
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <MonteCarlo: void run()> SUCCESSFUL
      * Optimization took 182
      * PEG2PEGTIME 172
      * PBTIME 142
      * ENGINETIME 2
      * Optimization ratio 6000/6000 = 1.0
      * PEG-based Optimization ratio 6000/6000 = 1.0
   - Done processing method <MonteCarlo: void run()>
+ Done optimizing MonteCarlo
+ Final results:
   - Skipped methods = 0
   - Buggy methods = 0
   - Total methods = 6
+ Fixing bytecode of method <MonteCarlo: void <init>()>
+ Fixing bytecode of method <MonteCarlo: void main()>
+ Fixing bytecode of method <MonteCarlo: double num_flops(int)>
+ Fixing bytecode of method <MonteCarlo: double integrate(int)>
+ Fixing bytecode of method <MonteCarlo: double measureMonteCarlo(double,Random)>
+ Fixing bytecode of method <MonteCarlo: void run()>
+ Writing class back to optimized/MonteCarlo.class
+ Total optimization time = 4205 milliseconds
'
END PEGGY OUTPUT
FFT
Command timed out
java -Xmx2000m -cp .:peggy_1.0.jar:uninlined-spec/scimark/ peggy.optimize.java.Main -O2 FFT -activate livsr:binop:constant -glpkPath "/glpk-5.0/examples/glpsol" -pb glpk -axioms axioms/java_arithmetic_axioms.xml:axioms/java_operator_axioms.xml:axioms/java_operator_costs.xml:axioms/java_util_axioms.xml -tmpFolder tmp
PEGGY OUTPUT:
b'+ Successfully added axiom file: axioms/java_operator_axioms.xml
+ Successfully added axiom file: axioms/java_util_axioms.xml
+ Successfully added axiom file: axioms/java_operator_costs.xml
+ Successfully added axiom file: axioms/java_arithmetic_axioms.xml
+ Loading class file FFT
+ Optimizing class FFT
   - Processing method <FFT: void <init>(int)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 14 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 14
GLPKFormulation: Number of values: 14
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <FFT: void <init>(int)> SUCCESSFUL
      * Optimization took 286
      * PEG2PEGTIME 228
      * PBTIME 149
      * ENGINETIME 6
      * Optimization ratio 2100/2100 = 1.0
      * PEG-based Optimization ratio 2100/2100 = 1.0
   - Done processing method <FFT: void <init>(int)>
   - Processing method <FFT: double num_flops(int)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 54 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 53
GLPKFormulation: Number of values: 31
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <FFT: double num_flops(int)> SUCCESSFUL
      * Optimization took 258
      * PEG2PEGTIME 247
      * PBTIME 163
      * ENGINETIME 54
      * Optimization ratio 3112/3112 = 1.0
      * PEG-based Optimization ratio 3112/3112 = 1.0
   - Done processing method <FFT: double num_flops(int)>
   - Processing method <FFT: long inst_main(java.lang.String[])>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 10 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 10
GLPKFormulation: Number of values: 10
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <FFT: long inst_main(java.lang.String[])> SUCCESSFUL
      * Optimization took 173
      * PEG2PEGTIME 165
      * PBTIME 133
      * ENGINETIME 2
      * Optimization ratio 3000/3000 = 1.0
      * PEG-based Optimization ratio 3000/3000 = 1.0
   - Done processing method <FFT: long inst_main(java.lang.String[])>
   - Processing method <FFT: void transform(double[])>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 12 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 12
GLPKFormulation: Number of values: 12
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <FFT: void transform(double[])> SUCCESSFUL
      * Optimization took 185
      * PEG2PEGTIME 176
      * PBTIME 135
      * ENGINETIME 3
      * Optimization ratio 3000/3000 = 1.0
      * PEG-based Optimization ratio 3000/3000 = 1.0
   - Done processing method <FFT: void transform(double[])>
   - Processing method <FFT: void inverse(double[])>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine reached iteration bound of 1000 after 486 milliseconds
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 1310
GLPKFormulation: Number of values: 935
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <FFT: void inverse(double[])> SUCCESSFUL
      * Optimization took 4431
      * PEG2PEGTIME 4384
      * PBTIME 3871
      * ENGINETIME 486
      * Optimization ratio 5650/5650 = 1.0
      * PEG-based Optimization ratio 5650/5650 = 1.0
   - Done processing method <FFT: void inverse(double[])>
   - Processing method <FFT: double test(double[])>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine reached iteration bound of 1000 after 363 milliseconds
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 1668
GLPKFormulation: Number of values: 1229
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <FFT: double test(double[])> SUCCESSFUL
      * Optimization took 7416
      * PEG2PEGTIME 7365
      * PBTIME 6985
      * ENGINETIME 363
      * Optimization ratio 13790/13790 = 1.0
      * PEG-based Optimization ratio 13790/13790 = 1.0
   - Done processing method <FFT: double test(double[])>
   - Processing method <FFT: double[] makeRandom(int)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine reached iteration bound of 1000 after 346 milliseconds
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 1101
GLPKFormulation: Number of values: 762
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <FFT: double[] makeRandom(int)> SUCCESSFUL
      * Optimization took 1949
      * PEG2PEGTIME 1925
      * PBTIME 1564
      * ENGINETIME 346
      * Optimization ratio 22294/22310 = 0.9992828328103989
      * PEG-based Optimization ratio 22294/22310 = 0.9992828328103989
   - Done processing method <FFT: double[] makeRandom(int)>
   - Processing method <FFT: void main(int)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 18 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 18
GLPKFormulation: Number of values: 18
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <FFT: void main(int)> SUCCESSFUL
      * Optimization took 197
      * PEG2PEGTIME 189
      * PBTIME 156
      * ENGINETIME 1
      * Optimization ratio 6000/6000 = 1.0
      * PEG-based Optimization ratio 6000/6000 = 1.0
   - Done processing method <FFT: void main(int)>
   - Method <FFT: int log2(int)> contains exceptions, skipping
   - Processing method <FFT: void transform_internal(double[],int)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine reached iteration bound of 1000 after 354 milliseconds
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 1894
GLPKFormulation: Number of values: 1520
         @ Running solver
'
END PEGGY OUTPUT
kernel
PEGGY OUTPUT:
b'+ Successfully added axiom file: axioms/java_operator_axioms.xml
+ Successfully added axiom file: axioms/java_util_axioms.xml
+ Successfully added axiom file: axioms/java_operator_costs.xml
+ Successfully added axiom file: axioms/java_arithmetic_axioms.xml
+ Loading class file kernel
+ Optimizing class kernel
   - Processing method <kernel: void <init>()>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 10 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 10
GLPKFormulation: Number of values: 10
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <kernel: void <init>()> SUCCESSFUL
      * Optimization took 309
      * PEG2PEGTIME 228
      * PBTIME 155
      * ENGINETIME 5
      * Optimization ratio 2000/2000 = 1.0
      * PEG-based Optimization ratio 2000/2000 = 1.0
   - Done processing method <kernel: void <init>()>
   - Processing method <kernel: double[] NewVectorCopy(double[])>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine reached iteration bound of 1000 after 536 milliseconds
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 1352
GLPKFormulation: Number of values: 977
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <kernel: double[] NewVectorCopy(double[])> SUCCESSFUL
      * Optimization took 3454
      * PEG2PEGTIME 3416
      * PBTIME 2847
      * ENGINETIME 536
      * Optimization ratio 3350/3350 = 1.0
      * PEG-based Optimization ratio 3350/3350 = 1.0
   - Done processing method <kernel: double[] NewVectorCopy(double[])>
   - Processing method <kernel: void CopyVector(double[],double[])>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine reached iteration bound of 1000 after 254 milliseconds
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 1346
GLPKFormulation: Number of values: 970
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <kernel: void CopyVector(double[],double[])> SUCCESSFUL
      * Optimization took 1985
      * PEG2PEGTIME 1959
      * PBTIME 1686
      * ENGINETIME 254
      * Optimization ratio 2350/2350 = 1.0
      * PEG-based Optimization ratio 2350/2350 = 1.0
   - Done processing method <kernel: void CopyVector(double[],double[])>
   - Processing method <kernel: double normabs(double[],double[])>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine reached iteration bound of 1000 after 332 milliseconds
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 735
GLPKFormulation: Number of values: 872
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <kernel: double normabs(double[],double[])> SUCCESSFUL
      * Optimization took 1769
      * PEG2PEGTIME 1722
      * PBTIME 1374
      * ENGINETIME 332
      * Optimization ratio 22530/22530 = 1.0
      * PEG-based Optimization ratio 22530/22530 = 1.0
   - Done processing method <kernel: double normabs(double[],double[])>
   - Processing method <kernel: void CopyMatrix(double[][],double[][])>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine reached iteration bound of 1000 after 420 milliseconds
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 843
GLPKFormulation: Number of values: 1886
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <kernel: void CopyMatrix(double[][],double[][])> SUCCESSFUL
      * Optimization took 13202
      * PEG2PEGTIME 13110
      * PBTIME 12674
      * ENGINETIME 420
      * Optimization ratio 109514/109514 = 1.0
      * PEG-based Optimization ratio 109514/109514 = 1.0
   - Done processing method <kernel: void CopyMatrix(double[][],double[][])>
   - Processing method <kernel: double[][] RandomizeMatrix(double[][],Random)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine reached iteration bound of 1000 after 212 milliseconds
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 695
GLPKFormulation: Number of values: 1178
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <kernel: double[][] RandomizeMatrix(double[][],Random)> SUCCESSFUL
      * Optimization took 2447
      * PEG2PEGTIME 2405
      * PBTIME 2176
      * ENGINETIME 212
      * Optimization ratio 339790/339790 = 1.0
      * PEG-based Optimization ratio 339790/339790 = 1.0
   - Done processing method <kernel: double[][] RandomizeMatrix(double[][],Random)>
   - Processing method <kernel: double[][] RandomMatrix(int,int,Random)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine reached iteration bound of 1000 after 239 milliseconds
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 824
GLPKFormulation: Number of values: 1158
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <kernel: double[][] RandomMatrix(int,int,Random)> SUCCESSFUL
      * Optimization took 1228
      * PEG2PEGTIME 1193
      * PBTIME 936
      * ENGINETIME 239
      * Optimization ratio 324190/324190 = 1.0
      * PEG-based Optimization ratio 324190/324190 = 1.0
   - Done processing method <kernel: double[][] RandomMatrix(int,int,Random)>
   - Processing method <kernel: double[] RandomVector(int,Random)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine reached iteration bound of 1000 after 163 milliseconds
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 1080
GLPKFormulation: Number of values: 759
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <kernel: double[] RandomVector(int,Random)> SUCCESSFUL
      * Optimization took 2764
      * PEG2PEGTIME 2746
      * PBTIME 2561
      * ENGINETIME 163
      * Optimization ratio 32290/32290 = 1.0
      * PEG-based Optimization ratio 32290/32290 = 1.0
   - Done processing method <kernel: double[] RandomVector(int,Random)>
   - Processing method <kernel: double[] RandomizeVector(double[],Random)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine reached iteration bound of 1000 after 158 milliseconds
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 892
GLPKFormulation: Number of values: 615
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <kernel: double[] RandomizeVector(double[],Random)> SUCCESSFUL
      * Optimization took 1739
      * PEG2PEGTIME 1720
      * PBTIME 1537
      * ENGINETIME 158
      * Optimization ratio 31890/31890 = 1.0
      * PEG-based Optimization ratio 31890/31890 = 1.0
   - Done processing method <kernel: double[] RandomizeVector(double[],Random)>
   - Processing method <kernel: double[] matvec(double[][],double[])>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 17 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 17
GLPKFormulation: Number of values: 17
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <kernel: double[] matvec(double[][],double[])> SUCCESSFUL
      * Optimization took 197
      * PEG2PEGTIME 190
      * PBTIME 163
      * ENGINETIME 1
      * Optimization ratio 3060/3060 = 1.0
      * PEG-based Optimization ratio 3060/3060 = 1.0
   - Done processing method <kernel: double[] matvec(double[][],double[])>
   - Processing method <kernel: void matvec(double[][],double[],double[])>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine reached iteration bound of 1000 after 198 milliseconds
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 823
GLPKFormulation: Number of values: 1430
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <kernel: void matvec(double[][],double[],double[])> SUCCESSFUL
      * Optimization took 5121
      * PEG2PEGTIME 5077
      * PBTIME 4856
      * ENGINETIME 198
      * Optimization ratio 28810/28810 = 1.0
      * PEG-based Optimization ratio 28810/28810 = 1.0
   - Done processing method <kernel: void matvec(double[][],double[],double[])>
   - Processing method <kernel: void init()>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 139 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 139
GLPKFormulation: Number of values: 139
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <kernel: void init()> SUCCESSFUL
      * Optimization took 296
      * PEG2PEGTIME 223
      * PBTIME 205
      * ENGINETIME 6
      * Optimization ratio 9910/9910 = 1.0
      * PEG-based Optimization ratio 9910/9910 = 1.0
   - Done processing method <kernel: void init()>
   - Processing method <kernel: void checkResults(java.lang.String,java.lang.String,int)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 61 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 61
GLPKFormulation: Number of values: 61
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <kernel: void checkResults(java.lang.String,java.lang.String,int)> SUCCESSFUL
      * Optimization took 242
      * PEG2PEGTIME 213
      * PBTIME 190
      * ENGINETIME 1
      * Optimization ratio 27110/27110 = 1.0
      * PEG-based Optimization ratio 27110/27110 = 1.0
   - Done processing method <kernel: void checkResults(java.lang.String,java.lang.String,int)>
   - Processing method <kernel: void <clinit>()>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 57 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 57
GLPKFormulation: Number of values: 57
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <kernel: void <clinit>()> SUCCESSFUL
      * Optimization took 227
      * PEG2PEGTIME 215
      * PBTIME 188
      * ENGINETIME 3
      * Optimization ratio 1400/1400 = 1.0
      * PEG-based Optimization ratio 1400/1400 = 1.0
   - Done processing method <kernel: void <clinit>()>
+ Done optimizing kernel
+ Final results:
   - Skipped methods = 0
   - Buggy methods = 0
   - Total methods = 14
+ Fixing bytecode of method <kernel: void <init>()>
+ Fixing bytecode of method <kernel: double[] NewVectorCopy(double[])>
+ Fixing bytecode of method <kernel: void CopyVector(double[],double[])>
+ Fixing bytecode of method <kernel: double normabs(double[],double[])>
+ Fixing bytecode of method <kernel: void CopyMatrix(double[][],double[][])>
+ Fixing bytecode of method <kernel: double[][] RandomizeMatrix(double[][],Random)>
+ Fixing bytecode of method <kernel: double[][] RandomMatrix(int,int,Random)>
+ Fixing bytecode of method <kernel: double[] RandomVector(int,Random)>
+ Fixing bytecode of method <kernel: double[] RandomizeVector(double[],Random)>
+ Fixing bytecode of method <kernel: double[] matvec(double[][],double[])>
+ Fixing bytecode of method <kernel: void matvec(double[][],double[],double[])>
+ Fixing bytecode of method <kernel: void init()>
+ Fixing bytecode of method <kernel: void checkResults(java.lang.String,java.lang.String,int)>
+ Fixing bytecode of method <kernel: void <clinit>()>
+ Writing class back to optimized/kernel.class
+ Total optimization time = 35583 milliseconds
'
END PEGGY OUTPUT
Stopwatch
PEGGY OUTPUT:
b'+ Successfully added axiom file: axioms/java_operator_axioms.xml
+ Successfully added axiom file: axioms/java_util_axioms.xml
+ Successfully added axiom file: axioms/java_operator_costs.xml
+ Successfully added axiom file: axioms/java_arithmetic_axioms.xml
+ Loading class file Stopwatch
+ Optimizing class Stopwatch
   - Processing method <Stopwatch: double seconds()>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 14 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 14
GLPKFormulation: Number of values: 13
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <Stopwatch: double seconds()> SUCCESSFUL
      * Optimization took 297
      * PEG2PEGTIME 242
      * PBTIME 157
      * ENGINETIME 11
      * Optimization ratio 2040/2040 = 1.0
      * PEG-based Optimization ratio 2040/2040 = 1.0
   - Done processing method <Stopwatch: double seconds()>
   - Processing method <Stopwatch: void reset()>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 17 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 17
GLPKFormulation: Number of values: 17
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <Stopwatch: void reset()> SUCCESSFUL
      * Optimization took 174
      * PEG2PEGTIME 166
      * PBTIME 135
      * ENGINETIME 3
      * Optimization ratio 300/300 = 1.0
      * PEG-based Optimization ratio 300/300 = 1.0
   - Done processing method <Stopwatch: void reset()>
   - Processing method <Stopwatch: void <init>()>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 13 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 13
GLPKFormulation: Number of values: 13
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <Stopwatch: void <init>()> SUCCESSFUL
      * Optimization took 163
      * PEG2PEGTIME 158
      * PBTIME 135
      * ENGINETIME 2
      * Optimization ratio 5000/5000 = 1.0
      * PEG-based Optimization ratio 5000/5000 = 1.0
   - Done processing method <Stopwatch: void <init>()>
   - Processing method <Stopwatch: void start()>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 28 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 28
GLPKFormulation: Number of values: 28
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <Stopwatch: void start()> SUCCESSFUL
      * Optimization took 193
      * PEG2PEGTIME 172
      * PBTIME 146
      * ENGINETIME 6
      * Optimization ratio 2405/2405 = 1.0
      * PEG-based Optimization ratio 2405/2405 = 1.0
   - Done processing method <Stopwatch: void start()>
   - Processing method <Stopwatch: void resume()>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 24 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 24
GLPKFormulation: Number of values: 24
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <Stopwatch: void resume()> SUCCESSFUL
      * Optimization took 175
      * PEG2PEGTIME 165
      * PBTIME 141
      * ENGINETIME 5
      * Optimization ratio 2305/2305 = 1.0
      * PEG-based Optimization ratio 2305/2305 = 1.0
   - Done processing method <Stopwatch: void resume()>
   - Processing method <Stopwatch: double stop()>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 37 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 37
GLPKFormulation: Number of values: 35
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <Stopwatch: double stop()> SUCCESSFUL
      * Optimization took 196
      * PEG2PEGTIME 181
      * PBTIME 154
      * ENGINETIME 9
      * Optimization ratio 2613/2613 = 1.0
      * PEG-based Optimization ratio 2613/2613 = 1.0
   - Done processing method <Stopwatch: double stop()>
   - Processing method <Stopwatch: double read()>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 40 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 40
GLPKFormulation: Number of values: 38
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <Stopwatch: double read()> SUCCESSFUL
      * Optimization took 189
      * PEG2PEGTIME 174
      * PBTIME 147
      * ENGINETIME 9
      * Optimization ratio 4613/4613 = 1.0
      * PEG-based Optimization ratio 4613/4613 = 1.0
   - Done processing method <Stopwatch: double read()>
+ Done optimizing Stopwatch
+ Final results:
   - Skipped methods = 0
   - Buggy methods = 0
   - Total methods = 7
+ Fixing bytecode of method <Stopwatch: double seconds()>
+ Fixing bytecode of method <Stopwatch: void reset()>
+ Fixing bytecode of method <Stopwatch: void <init>()>
+ Fixing bytecode of method <Stopwatch: void start()>
+ Fixing bytecode of method <Stopwatch: void resume()>
+ Fixing bytecode of method <Stopwatch: double stop()>
+ Fixing bytecode of method <Stopwatch: double read()>
+ Writing class back to optimized/Stopwatch.class
+ Total optimization time = 1648 milliseconds
'
END PEGGY OUTPUT
BENCHMARKING inlined-spec/scimark/
LU
Command timed out
java -Xmx2000m -cp .:peggy_1.0.jar:inlined-spec/scimark/ peggy.optimize.java.Main -O2 LU -activate livsr:binop:constant -glpkPath "/glpk-5.0/examples/glpsol" -pb glpk -axioms axioms/java_arithmetic_axioms.xml:axioms/java_operator_axioms.xml:axioms/java_operator_costs.xml:axioms/java_util_axioms.xml -tmpFolder tmp
PEGGY OUTPUT:
b'+ Successfully added axiom file: axioms/java_operator_axioms.xml
+ Successfully added axiom file: axioms/java_util_axioms.xml
+ Successfully added axiom file: axioms/java_operator_costs.xml
+ Successfully added axiom file: axioms/java_arithmetic_axioms.xml
+ Loading class file LU
+ Optimizing class LU
   - Processing method <LU: void <init>(int)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 14 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 14
GLPKFormulation: Number of values: 14
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <LU: void <init>(int)> SUCCESSFUL
      * Optimization took 321
      * PEG2PEGTIME 238
      * PBTIME 157
      * ENGINETIME 5
      * Optimization ratio 2100/2100 = 1.0
      * PEG-based Optimization ratio 2100/2100 = 1.0
   - Done processing method <LU: void <init>(int)>
   - Method <LU: void main(int)> contains exceptions, skipping
   - Processing method <LU: double num_flops(int)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 16 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 16
GLPKFormulation: Number of values: 13
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <LU: double num_flops(int)> SUCCESSFUL
      * Optimization took 182
      * PEG2PEGTIME 178
      * PBTIME 141
      * ENGINETIME 12
      * Optimization ratio 120/120 = 1.0
      * PEG-based Optimization ratio 120/120 = 1.0
   - Done processing method <LU: double num_flops(int)>
   - Processing method <LU: double[] new_copy(double[])>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine reached iteration bound of 1000 after 499 milliseconds
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 1358
GLPKFormulation: Number of values: 985
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <LU: double[] new_copy(double[])> SUCCESSFUL
      * Optimization took 2494
      * PEG2PEGTIME 2465
      * PBTIME 1928
      * ENGINETIME 499
      * Optimization ratio 3350/3350 = 1.0
      * PEG-based Optimization ratio 3350/3350 = 1.0
   - Done processing method <LU: double[] new_copy(double[])>
   - Processing method <LU: double[][] new_copy(double[][])>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine reached iteration bound of 1000 after 357 milliseconds
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 1119
GLPKFormulation: Number of values: 1383
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <LU: double[][] new_copy(double[][])> SUCCESSFUL
      * Optimization took 8302
      * PEG2PEGTIME 8258
      * PBTIME 7885
      * ENGINETIME 357
      * Optimization ratio 26410/26410 = 1.0
      * PEG-based Optimization ratio 26410/26410 = 1.0
   - Done processing method <LU: double[][] new_copy(double[][])>
   - Processing method <LU: int[] new_copy(int[])>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine reached iteration bound of 1000 after 204 milliseconds
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 1346
GLPKFormulation: Number of values: 971
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <LU: int[] new_copy(int[])> SUCCESSFUL
      * Optimization took 2683
      * PEG2PEGTIME 2665
      * PBTIME 2435
      * ENGINETIME 204
      * Optimization ratio 3350/3350 = 1.0
      * PEG-based Optimization ratio 3350/3350 = 1.0
   - Done processing method <LU: int[] new_copy(int[])>
   - Processing method <LU: void insert_copy(double[][],double[][])>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine reached iteration bound of 1000 after 241 milliseconds
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 851
GLPKFormulation: Number of values: 1858
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <LU: void insert_copy(double[][],double[][])> SUCCESSFUL
      * Optimization took 62590
      * PEG2PEGTIME 62514
      * PBTIME 62245
      * ENGINETIME 241
      * Optimization ratio 109514/109514 = 1.0
      * PEG-based Optimization ratio 109514/109514 = 1.0
   - Done processing method <LU: void insert_copy(double[][],double[][])>
   - Processing method <LU: double[][] getLU()>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine reached iteration bound of 1000 after 241 milliseconds
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 1103
GLPKFormulation: Number of values: 1341
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <LU: double[][] getLU()> SUCCESSFUL
      * Optimization took 4347
      * PEG2PEGTIME 4305
      * PBTIME 4049
      * ENGINETIME 241
      * Optimization ratio 27610/27610 = 1.0
      * PEG-based Optimization ratio 27610/27610 = 1.0
   - Done processing method <LU: double[][] getLU()>
   - Processing method <LU: int[] getPivot()>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine reached iteration bound of 1000 after 154 milliseconds
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 1173
GLPKFormulation: Number of values: 871
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <LU: int[] getPivot()> SUCCESSFUL
      * Optimization took 3459
      * PEG2PEGTIME 3441
      * PBTIME 3265
      * ENGINETIME 154
      * Optimization ratio 4450/4450 = 1.0
      * PEG-based Optimization ratio 4450/4450 = 1.0
   - Done processing method <LU: int[] getPivot()>
   - Processing method <LU: double[] solve(double[])>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine reached iteration bound of 1000 after 198 milliseconds
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 711
GLPKFormulation: Number of values: 1640
         @ Running solver
'
END PEGGY OUTPUT
Random
Command failed
java -Xmx2000m -cp .:peggy_1.0.jar:inlined-spec/scimark/ peggy.optimize.java.Main -O2 Random -activate livsr:binop:constant -glpkPath "/glpk-5.0/examples/glpsol" -pb glpk -axioms axioms/java_arithmetic_axioms.xml:axioms/java_operator_axioms.xml:axioms/java_operator_costs.xml:axioms/java_util_axioms.xml -tmpFolder tmp
PEGGY OUTPUT:
b'+ Successfully added axiom file: axioms/java_operator_axioms.xml
+ Successfully added axiom file: axioms/java_util_axioms.xml
+ Successfully added axiom file: axioms/java_operator_costs.xml
+ Successfully added axiom file: axioms/java_arithmetic_axioms.xml
+ Loading class file Random
+ Optimizing class Random
   - Processing method <Random: void <init>()>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine reached iteration bound of 1000 after 516 milliseconds
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 795
GLPKFormulation: Number of values: 668
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <Random: void <init>()> SUCCESSFUL
      * Optimization took 21857
      * PEG2PEGTIME 21722
      * PBTIME 21123
      * ENGINETIME 516
      * Optimization ratio 14719/14779 = 0.9959401853982002
      * PEG-based Optimization ratio 14719/14959 = 0.9839561468012568
   - Done processing method <Random: void <init>()>
   - Processing method <Random: void <init>(double,double)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine reached iteration bound of 1000 after 261 milliseconds
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 811
GLPKFormulation: Number of values: 680
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <Random: void <init>(double,double)> SUCCESSFUL
      * Optimization took 20054
      * PEG2PEGTIME 19964
      * PBTIME 19683
      * ENGINETIME 261
      * Optimization ratio 15123/15183 = 0.9960482118158467
      * PEG-based Optimization ratio 15123/15363 = 0.9843780511618825
   - Done processing method <Random: void <init>(double,double)>
   - Processing method <Random: void <init>(int)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine reached iteration bound of 1000 after 212 milliseconds
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 791
GLPKFormulation: Number of values: 664
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <Random: void <init>(int)> SUCCESSFUL
      * Optimization took 70602
      * PEG2PEGTIME 70531
      * PBTIME 70301
      * ENGINETIME 212
      * Optimization ratio 12699/12759 = 0.9952974371032213
      * PEG-based Optimization ratio 12699/12939 = 0.9814514259216323
   - Done processing method <Random: void <init>(int)>
   - Processing method <Random: void <init>(int,double,double)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine reached iteration bound of 1000 after 199 milliseconds
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 809
GLPKFormulation: Number of values: 685
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <Random: void <init>(int,double,double)> SUCCESSFUL
      * Optimization took 126544
      * PEG2PEGTIME 126479
      * PBTIME 126264
      * ENGINETIME 199
      * Optimization ratio 13103/13163 = 0.9954417685937856
      * PEG-based Optimization ratio 13103/13343 = 0.9820130405456045
   - Done processing method <Random: void <init>(int,double,double)>
   - Processing method <Random: double nextDouble()>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 104 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 104
GLPKFormulation: Number of values: 97
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <Random: double nextDouble()> SUCCESSFUL
      * Optimization took 226
      * PEG2PEGTIME 163
      * PBTIME 143
      * ENGINETIME 4
      * Optimization ratio 2320/2320 = 1.0
      * PEG-based Optimization ratio 2320/2320 = 1.0
   - Done processing method <Random: double nextDouble()>
   - Processing method <Random: void nextDoubles(double[])>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine reached iteration bound of 1000 after 134 milliseconds
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 777
GLPKFormulation: Number of values: 983
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <Random: void nextDoubles(double[])> SUCCESSFUL
      * Optimization took 3215
      * PEG2PEGTIME 2678
      * PBTIME 2518
      * ENGINETIME 134
Exception in thread "main" java.lang.NullPointerException
\tat peggy.analysis.PEGCostCalculator.assignVariance(PEGCostCalculator.java:39)
\tat peggy.analysis.PEGCostCalculator.cost(PEGCostCalculator.java:91)
\tat peggy.optimize.java.Main.calculatePEGCost(Main.java:2348)
\tat peggy.optimize.java.Main.optimizeAll(Main.java:906)
\tat peggy.optimize.java.Main.optimizeClass(Main.java:704)
\tat peggy.optimize.java.Main.main(Main.java:2881)
'
END PEGGY OUTPUT
SparseCompRow
PEGGY OUTPUT:
b'+ Successfully added axiom file: axioms/java_operator_axioms.xml
+ Successfully added axiom file: axioms/java_util_axioms.xml
+ Successfully added axiom file: axioms/java_operator_costs.xml
+ Successfully added axiom file: axioms/java_arithmetic_axioms.xml
+ Loading class file SparseCompRow
+ Optimizing class SparseCompRow
   - Processing method <SparseCompRow: void <init>(int)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 14 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 14
GLPKFormulation: Number of values: 14
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <SparseCompRow: void <init>(int)> SUCCESSFUL
      * Optimization took 316
      * PEG2PEGTIME 233
      * PBTIME 154
      * ENGINETIME 5
      * Optimization ratio 2100/2100 = 1.0
      * PEG-based Optimization ratio 2100/2100 = 1.0
   - Done processing method <SparseCompRow: void <init>(int)>
   - Method <SparseCompRow: void main(int)> contains exceptions, skipping
   - Processing method <SparseCompRow: double num_flops(int,int,int)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 18 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 18
GLPKFormulation: Number of values: 15
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <SparseCompRow: double num_flops(int,int,int)> SUCCESSFUL
      * Optimization took 184
      * PEG2PEGTIME 178
      * PBTIME 138
      * ENGINETIME 13
      * Optimization ratio 140/140 = 1.0
      * PEG-based Optimization ratio 140/140 = 1.0
   - Done processing method <SparseCompRow: double num_flops(int,int,int)>
   - Processing method <SparseCompRow: void matmult(double[],double[],int[],int[],double[],int,int)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine reached iteration bound of 1000 after 535 milliseconds
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 917
GLPKFormulation: Number of values: 1292
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <SparseCompRow: void matmult(double[],double[],int[],int[],double[],int,int)> SUCCESSFUL
      * Optimization took 25322
      * PEG2PEGTIME 25126
      * PBTIME 24531
      * ENGINETIME 535
      * Optimization ratio 437659/437659 = 1.0
      * PEG-based Optimization ratio 437659/437659 = 1.0
   - Done processing method <SparseCompRow: void matmult(double[],double[],int[],int[],double[],int,int)>
   - Method <SparseCompRow: double measureSparseMatmult(int,int,double,Random)> contains exceptions, skipping
   - Method <SparseCompRow: void run()> contains exceptions, skipping
+ Done optimizing SparseCompRow
+ Final results:
   - Skipped methods = 3
   - Buggy methods = 0
   - Total methods = 6
+ Fixing bytecode of method <SparseCompRow: void <init>(int)>
+ Fixing bytecode of method <SparseCompRow: void main(int)>
+ Fixing bytecode of method <SparseCompRow: double num_flops(int,int,int)>
+ Fixing bytecode of method <SparseCompRow: void matmult(double[],double[],int[],int[],double[],int,int)>
+ Fixing bytecode of method <SparseCompRow: double measureSparseMatmult(int,int,double,Random)>
+ Fixing bytecode of method <SparseCompRow: void run()>
+ Writing class back to optimized/SparseCompRow.class
+ Total optimization time = 26881 milliseconds
'
END PEGGY OUTPUT
SOR
Command timed out
java -Xmx2000m -cp .:peggy_1.0.jar:inlined-spec/scimark/ peggy.optimize.java.Main -O2 SOR -activate livsr:binop:constant -glpkPath "/glpk-5.0/examples/glpsol" -pb glpk -axioms axioms/java_arithmetic_axioms.xml:axioms/java_operator_axioms.xml:axioms/java_operator_costs.xml:axioms/java_util_axioms.xml -tmpFolder tmp
PEGGY OUTPUT:
b'+ Successfully added axiom file: axioms/java_operator_axioms.xml
+ Successfully added axiom file: axioms/java_util_axioms.xml
+ Successfully added axiom file: axioms/java_operator_costs.xml
+ Successfully added axiom file: axioms/java_arithmetic_axioms.xml
+ Loading class file SOR
+ Optimizing class SOR
   - Processing method <SOR: void <init>(int)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 14 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 14
GLPKFormulation: Number of values: 14
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <SOR: void <init>(int)> SUCCESSFUL
      * Optimization took 294
      * PEG2PEGTIME 236
      * PBTIME 160
      * ENGINETIME 5
      * Optimization ratio 2100/2100 = 1.0
      * PEG-based Optimization ratio 2100/2100 = 1.0
   - Done processing method <SOR: void <init>(int)>
   - Method <SOR: void main(int)> contains exceptions, skipping
   - Processing method <SOR: double num_flops(int,int,int)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 360 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 315
GLPKFormulation: Number of values: 87
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <SOR: double num_flops(int,int,int)> SUCCESSFUL
      * Optimization took 4897
      * PEG2PEGTIME 4891
      * PBTIME 4569
      * ENGINETIME 287
      * Optimization ratio 128/128 = 1.0
      * PEG-based Optimization ratio 128/128 = 1.0
   - Done processing method <SOR: double num_flops(int,int,int)>
   - Processing method <SOR: double execute(double,double[][],int)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine reached iteration bound of 1000 after 519 milliseconds
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 1314
GLPKFormulation: Number of values: 2048
         @ Running solver
'
END PEGGY OUTPUT
MonteCarlo
PEGGY OUTPUT:
b'+ Successfully added axiom file: axioms/java_operator_axioms.xml
+ Successfully added axiom file: axioms/java_util_axioms.xml
+ Successfully added axiom file: axioms/java_operator_costs.xml
+ Successfully added axiom file: axioms/java_arithmetic_axioms.xml
+ Loading class file MonteCarlo
+ Optimizing class MonteCarlo
   - Processing method <MonteCarlo: void <init>()>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 10 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 10
GLPKFormulation: Number of values: 10
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <MonteCarlo: void <init>()> SUCCESSFUL
      * Optimization took 305
      * PEG2PEGTIME 225
      * PBTIME 151
      * ENGINETIME 4
      * Optimization ratio 2000/2000 = 1.0
      * PEG-based Optimization ratio 2000/2000 = 1.0
   - Done processing method <MonteCarlo: void <init>()>
   - Method <MonteCarlo: void main()> contains exceptions, skipping
   - Processing method <MonteCarlo: double num_flops(int)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 10 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 10
GLPKFormulation: Number of values: 9
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <MonteCarlo: double num_flops(int)> SUCCESSFUL
      * Optimization took 167
      * PEG2PEGTIME 163
      * PBTIME 129
      * ENGINETIME 8
      * Optimization ratio 40/40 = 1.0
      * PEG-based Optimization ratio 40/40 = 1.0
   - Done processing method <MonteCarlo: double num_flops(int)>
   - Method <MonteCarlo: double integrate(int)> contains exceptions, skipping
   - Method <MonteCarlo: double measureMonteCarlo(double,Random)> contains exceptions, skipping
   - Method <MonteCarlo: void run()> contains exceptions, skipping
+ Done optimizing MonteCarlo
+ Final results:
   - Skipped methods = 4
   - Buggy methods = 0
   - Total methods = 6
+ Fixing bytecode of method <MonteCarlo: void <init>()>
+ Fixing bytecode of method <MonteCarlo: void main()>
+ Fixing bytecode of method <MonteCarlo: double num_flops(int)>
+ Fixing bytecode of method <MonteCarlo: double integrate(int)>
+ Fixing bytecode of method <MonteCarlo: double measureMonteCarlo(double,Random)>
+ Fixing bytecode of method <MonteCarlo: void run()>
+ Writing class back to optimized/MonteCarlo.class
+ Total optimization time = 1370 milliseconds
'
END PEGGY OUTPUT
FFT
PEGGY OUTPUT:
b'+ Successfully added axiom file: axioms/java_operator_axioms.xml
+ Successfully added axiom file: axioms/java_util_axioms.xml
+ Successfully added axiom file: axioms/java_operator_costs.xml
+ Successfully added axiom file: axioms/java_arithmetic_axioms.xml
+ Loading class file FFT
+ Optimizing class FFT
   - Processing method <FFT: void <init>(int)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 14 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 14
GLPKFormulation: Number of values: 14
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <FFT: void <init>(int)> SUCCESSFUL
      * Optimization took 314
      * PEG2PEGTIME 231
      * PBTIME 154
      * ENGINETIME 6
      * Optimization ratio 2100/2100 = 1.0
      * PEG-based Optimization ratio 2100/2100 = 1.0
   - Done processing method <FFT: void <init>(int)>
   - Method <FFT: double num_flops(int)> contains exceptions, skipping
   - Method <FFT: long inst_main(java.lang.String[])> contains exceptions, skipping
   - Method <FFT: void transform(double[])> contains exceptions, skipping
   - Method <FFT: void inverse(double[])> contains exceptions, skipping
   - Method <FFT: double test(double[])> contains exceptions, skipping
   - Processing method <FFT: double[] makeRandom(int)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine reached iteration bound of 1000 after 794 milliseconds
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 1101
GLPKFormulation: Number of values: 762
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <FFT: double[] makeRandom(int)> SUCCESSFUL
      * Optimization took 3589
      * PEG2PEGTIME 3558
      * PBTIME 2729
      * ENGINETIME 794
      * Optimization ratio 22294/22310 = 0.9992828328103989
      * PEG-based Optimization ratio 22294/22310 = 0.9992828328103989
   - Done processing method <FFT: double[] makeRandom(int)>
   - Method <FFT: void main(int)> contains exceptions, skipping
   - Method <FFT: int log2(int)> contains exceptions, skipping
   - Method <FFT: void transform_internal(double[],int)> contains exceptions, skipping
   - Processing method <FFT: void bitreverse(double[])>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine reached iteration bound of 1000 after 536 milliseconds
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 1406
GLPKFormulation: Number of values: 1571
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <FFT: void bitreverse(double[])> SUCCESSFUL
      * Optimization took 6611
      * PEG2PEGTIME 6538
      * PBTIME 5976
      * ENGINETIME 536
      * Optimization ratio 11806/11806 = 1.0
      * PEG-based Optimization ratio 11806/11806 = 1.0
   - Done processing method <FFT: void bitreverse(double[])>
   - Method <FFT: double measureFFT(int,double,Random)> contains exceptions, skipping
   - Method <FFT: void run()> contains exceptions, skipping
   - Processing method <FFT: void <clinit>()>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 16 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 16
GLPKFormulation: Number of values: 16
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <FFT: void <clinit>()> SUCCESSFUL
      * Optimization took 188
      * PEG2PEGTIME 185
      * PBTIME 168
      * ENGINETIME 0
      * Optimization ratio 3100/3100 = 1.0
      * PEG-based Optimization ratio 3100/3100 = 1.0
   - Done processing method <FFT: void <clinit>()>
+ Done optimizing FFT
+ Final results:
   - Skipped methods = 10
   - Buggy methods = 0
   - Total methods = 14
+ Fixing bytecode of method <FFT: void <init>(int)>
+ Fixing bytecode of method <FFT: double num_flops(int)>
+ Fixing bytecode of method <FFT: long inst_main(java.lang.String[])>
+ Fixing bytecode of method <FFT: void transform(double[])>
+ Fixing bytecode of method <FFT: void inverse(double[])>
+ Fixing bytecode of method <FFT: double test(double[])>
+ Fixing bytecode of method <FFT: double[] makeRandom(int)>
+ Fixing bytecode of method <FFT: void main(int)>
+ Fixing bytecode of method <FFT: int log2(int)>
+ Fixing bytecode of method <FFT: void transform_internal(double[],int)>
+ Fixing bytecode of method <FFT: void bitreverse(double[])>
+ Fixing bytecode of method <FFT: double measureFFT(int,double,Random)>
+ Fixing bytecode of method <FFT: void run()>
+ Fixing bytecode of method <FFT: void <clinit>()>
+ Writing class back to optimized/FFT.class
+ Total optimization time = 14071 milliseconds
'
END PEGGY OUTPUT
kernel
PEGGY OUTPUT:
b'+ Successfully added axiom file: axioms/java_operator_axioms.xml
+ Successfully added axiom file: axioms/java_util_axioms.xml
+ Successfully added axiom file: axioms/java_operator_costs.xml
+ Successfully added axiom file: axioms/java_arithmetic_axioms.xml
+ Loading class file kernel
+ Optimizing class kernel
   - Processing method <kernel: void <init>()>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 10 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 10
GLPKFormulation: Number of values: 10
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <kernel: void <init>()> SUCCESSFUL
      * Optimization took 285
      * PEG2PEGTIME 229
      * PBTIME 152
      * ENGINETIME 4
      * Optimization ratio 2000/2000 = 1.0
      * PEG-based Optimization ratio 2000/2000 = 1.0
   - Done processing method <kernel: void <init>()>
   - Processing method <kernel: double[] NewVectorCopy(double[])>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine reached iteration bound of 1000 after 532 milliseconds
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 1354
GLPKFormulation: Number of values: 982
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <kernel: double[] NewVectorCopy(double[])> SUCCESSFUL
      * Optimization took 3148
      * PEG2PEGTIME 3110
      * PBTIME 2546
      * ENGINETIME 532
      * Optimization ratio 3350/3350 = 1.0
      * PEG-based Optimization ratio 3350/3350 = 1.0
   - Done processing method <kernel: double[] NewVectorCopy(double[])>
   - Processing method <kernel: void CopyVector(double[],double[])>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine reached iteration bound of 1000 after 260 milliseconds
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 1362
GLPKFormulation: Number of values: 986
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <kernel: void CopyVector(double[],double[])> SUCCESSFUL
      * Optimization took 5200
      * PEG2PEGTIME 5175
      * PBTIME 4898
      * ENGINETIME 260
      * Optimization ratio 2350/2350 = 1.0
      * PEG-based Optimization ratio 2350/2350 = 1.0
   - Done processing method <kernel: void CopyVector(double[],double[])>
   - Processing method <kernel: double normabs(double[],double[])>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine reached iteration bound of 1000 after 334 milliseconds
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 731
GLPKFormulation: Number of values: 890
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <kernel: double normabs(double[],double[])> SUCCESSFUL
      * Optimization took 1885
      * PEG2PEGTIME 1836
      * PBTIME 1486
      * ENGINETIME 334
      * Optimization ratio 22530/22530 = 1.0
      * PEG-based Optimization ratio 22530/22530 = 1.0
   - Done processing method <kernel: double normabs(double[],double[])>
   - Processing method <kernel: void CopyMatrix(double[][],double[][])>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine reached iteration bound of 1000 after 420 milliseconds
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 845
GLPKFormulation: Number of values: 1901
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <kernel: void CopyMatrix(double[][],double[][])> SUCCESSFUL
      * Optimization took 9504
      * PEG2PEGTIME 9412
      * PBTIME 8976
      * ENGINETIME 420
      * Optimization ratio 109514/109514 = 1.0
      * PEG-based Optimization ratio 109514/109514 = 1.0
   - Done processing method <kernel: void CopyMatrix(double[][],double[][])>
   - Method <kernel: double[][] RandomizeMatrix(double[][],Random)> contains exceptions, skipping
   - Method <kernel: double[][] RandomMatrix(int,int,Random)> contains exceptions, skipping
   - Method <kernel: double[] RandomVector(int,Random)> contains exceptions, skipping
   - Method <kernel: double[] RandomizeVector(double[],Random)> contains exceptions, skipping
   - Processing method <kernel: double[] matvec(double[][],double[])>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine reached iteration bound of 1000 after 267 milliseconds
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 814
GLPKFormulation: Number of values: 1385
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <kernel: double[] matvec(double[][],double[])> SUCCESSFUL
      * Optimization took 2872
      * PEG2PEGTIME 2826
      * PBTIME 2540
      * ENGINETIME 267
      * Optimization ratio 29870/29870 = 1.0
      * PEG-based Optimization ratio 29870/29870 = 1.0
   - Done processing method <kernel: double[] matvec(double[][],double[])>
   - Processing method <kernel: void matvec(double[][],double[],double[])>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine reached iteration bound of 1000 after 226 milliseconds
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 815
GLPKFormulation: Number of values: 1409
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <kernel: void matvec(double[][],double[],double[])> SUCCESSFUL
      * Optimization took 4837
      * PEG2PEGTIME 4796
      * PBTIME 4552
      * ENGINETIME 226
      * Optimization ratio 28810/28810 = 1.0
      * PEG-based Optimization ratio 28810/28810 = 1.0
   - Done processing method <kernel: void matvec(double[][],double[],double[])>
   - Processing method <kernel: void init()>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 139 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 139
GLPKFormulation: Number of values: 139
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <kernel: void init()> SUCCESSFUL
      * Optimization took 293
      * PEG2PEGTIME 220
      * PBTIME 194
      * ENGINETIME 6
      * Optimization ratio 9910/9910 = 1.0
      * PEG-based Optimization ratio 9910/9910 = 1.0
   - Done processing method <kernel: void init()>
   - Processing method <kernel: void checkResults(java.lang.String,java.lang.String,int)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 61 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 61
GLPKFormulation: Number of values: 61
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <kernel: void checkResults(java.lang.String,java.lang.String,int)> SUCCESSFUL
      * Optimization took 220
      * PEG2PEGTIME 191
      * PBTIME 176
      * ENGINETIME 2
      * Optimization ratio 27110/27110 = 1.0
      * PEG-based Optimization ratio 27110/27110 = 1.0
   - Done processing method <kernel: void checkResults(java.lang.String,java.lang.String,int)>
   - Processing method <kernel: void <clinit>()>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 57 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 57
GLPKFormulation: Number of values: 57
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <kernel: void <clinit>()> SUCCESSFUL
      * Optimization took 213
      * PEG2PEGTIME 203
      * PBTIME 174
      * ENGINETIME 4
      * Optimization ratio 1400/1400 = 1.0
      * PEG-based Optimization ratio 1400/1400 = 1.0
   - Done processing method <kernel: void <clinit>()>
+ Done optimizing kernel
+ Final results:
   - Skipped methods = 4
   - Buggy methods = 0
   - Total methods = 14
+ Fixing bytecode of method <kernel: void <init>()>
+ Fixing bytecode of method <kernel: double[] NewVectorCopy(double[])>
+ Fixing bytecode of method <kernel: void CopyVector(double[],double[])>
+ Fixing bytecode of method <kernel: double normabs(double[],double[])>
+ Fixing bytecode of method <kernel: void CopyMatrix(double[][],double[][])>
+ Fixing bytecode of method <kernel: double[][] RandomizeMatrix(double[][],Random)>
+ Fixing bytecode of method <kernel: double[][] RandomMatrix(int,int,Random)>
+ Fixing bytecode of method <kernel: double[] RandomVector(int,Random)>
+ Fixing bytecode of method <kernel: double[] RandomizeVector(double[],Random)>
+ Fixing bytecode of method <kernel: double[] matvec(double[][],double[])>
+ Fixing bytecode of method <kernel: void matvec(double[][],double[],double[])>
+ Fixing bytecode of method <kernel: void init()>
+ Fixing bytecode of method <kernel: void checkResults(java.lang.String,java.lang.String,int)>
+ Fixing bytecode of method <kernel: void <clinit>()>
+ Writing class back to optimized/kernel.class
+ Total optimization time = 29192 milliseconds
'
END PEGGY OUTPUT
Stopwatch
PEGGY OUTPUT:
b'+ Successfully added axiom file: axioms/java_operator_axioms.xml
+ Successfully added axiom file: axioms/java_util_axioms.xml
+ Successfully added axiom file: axioms/java_operator_costs.xml
+ Successfully added axiom file: axioms/java_arithmetic_axioms.xml
+ Loading class file Stopwatch
+ Optimizing class Stopwatch
   - Processing method <Stopwatch: double seconds()>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 14 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 14
GLPKFormulation: Number of values: 13
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <Stopwatch: double seconds()> SUCCESSFUL
      * Optimization took 322
      * PEG2PEGTIME 240
      * PBTIME 157
      * ENGINETIME 11
      * Optimization ratio 2040/2040 = 1.0
      * PEG-based Optimization ratio 2040/2040 = 1.0
   - Done processing method <Stopwatch: double seconds()>
   - Processing method <Stopwatch: void reset()>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 17 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 17
GLPKFormulation: Number of values: 17
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <Stopwatch: void reset()> SUCCESSFUL
      * Optimization took 181
      * PEG2PEGTIME 170
      * PBTIME 138
      * ENGINETIME 3
      * Optimization ratio 300/300 = 1.0
      * PEG-based Optimization ratio 300/300 = 1.0
   - Done processing method <Stopwatch: void reset()>
   - Processing method <Stopwatch: void <init>()>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 21 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 21
GLPKFormulation: Number of values: 21
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <Stopwatch: void <init>()> SUCCESSFUL
      * Optimization took 191
      * PEG2PEGTIME 179
      * PBTIME 140
      * ENGINETIME 4
      * Optimization ratio 2300/2300 = 1.0
      * PEG-based Optimization ratio 2300/2300 = 1.0
   - Done processing method <Stopwatch: void <init>()>
   - Processing method <Stopwatch: void start()>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 33 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 33
GLPKFormulation: Number of values: 32
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <Stopwatch: void start()> SUCCESSFUL
      * Optimization took 231
      * PEG2PEGTIME 190
      * PBTIME 151
      * ENGINETIME 8
      * Optimization ratio 2445/2445 = 1.0
      * PEG-based Optimization ratio 2445/2445 = 1.0
   - Done processing method <Stopwatch: void start()>
   - Processing method <Stopwatch: void resume()>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 29 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 29
GLPKFormulation: Number of values: 28
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <Stopwatch: void resume()> SUCCESSFUL
      * Optimization took 192
      * PEG2PEGTIME 172
      * PBTIME 144
      * ENGINETIME 7
      * Optimization ratio 2345/2345 = 1.0
      * PEG-based Optimization ratio 2345/2345 = 1.0
   - Done processing method <Stopwatch: void resume()>
   - Processing method <Stopwatch: double stop()>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 42 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 42
GLPKFormulation: Number of values: 39
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <Stopwatch: double stop()> SUCCESSFUL
      * Optimization took 226
      * PEG2PEGTIME 192
      * PBTIME 158
      * ENGINETIME 10
      * Optimization ratio 2653/2653 = 1.0
      * PEG-based Optimization ratio 2653/2653 = 1.0
   - Done processing method <Stopwatch: double stop()>
   - Processing method <Stopwatch: double read()>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 48 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 48
GLPKFormulation: Number of values: 44
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <Stopwatch: double read()> SUCCESSFUL
      * Optimization took 221
      * PEG2PEGTIME 185
      * PBTIME 154
      * ENGINETIME 12
      * Optimization ratio 4693/4693 = 1.0
      * PEG-based Optimization ratio 4693/4693 = 1.0
   - Done processing method <Stopwatch: double read()>
+ Done optimizing Stopwatch
+ Final results:
   - Skipped methods = 0
   - Buggy methods = 0
   - Total methods = 7
+ Fixing bytecode of method <Stopwatch: double seconds()>
+ Fixing bytecode of method <Stopwatch: void reset()>
+ Fixing bytecode of method <Stopwatch: void <init>()>
+ Fixing bytecode of method <Stopwatch: void start()>
+ Fixing bytecode of method <Stopwatch: void resume()>
+ Fixing bytecode of method <Stopwatch: double stop()>
+ Fixing bytecode of method <Stopwatch: double read()>
+ Writing class back to optimized/Stopwatch.class
+ Total optimization time = 1916 milliseconds
'
END PEGGY OUTPUT
BENCHMARKING benchmark/passing/
DeadLoopDeletion
PEGGY OUTPUT:
b'+ Successfully added axiom file: axioms/java_operator_axioms.xml
+ Successfully added axiom file: axioms/java_util_axioms.xml
+ Successfully added axiom file: axioms/java_operator_costs.xml
+ Successfully added axiom file: axioms/java_arithmetic_axioms.xml
+ Loading class file DeadLoopDeletion
+ Optimizing class DeadLoopDeletion
   - Processing method <DeadLoopDeletion: void <init>()>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 10 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 10
GLPKFormulation: Number of values: 10
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <DeadLoopDeletion: void <init>()> SUCCESSFUL
      * Optimization took 315
      * PEG2PEGTIME 233
      * PBTIME 154
      * ENGINETIME 5
      * Optimization ratio 2000/2000 = 1.0
      * PEG-based Optimization ratio 2000/2000 = 1.0
   - Done processing method <DeadLoopDeletion: void <init>()>
   - Processing method <DeadLoopDeletion: int original()>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 5 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 5
GLPKFormulation: Number of values: 5
         @ Running solver
         @ No result from ILP solver
      * Original PEG chosen as output
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <DeadLoopDeletion: int original()> SUCCESSFUL
      * Optimization took 160
      * PEG2PEGTIME 155
      * PBTIME 127
      * ENGINETIME 1
   - Done processing method <DeadLoopDeletion: int original()>
+ Done optimizing DeadLoopDeletion
+ Final results:
   - Skipped methods = 0
   - Buggy methods = 0
   - Total methods = 2
+ Fixing bytecode of method <DeadLoopDeletion: void <init>()>
+ Fixing bytecode of method <DeadLoopDeletion: int original()>
+ Writing class back to optimized/DeadLoopDeletion.class
+ Total optimization time = 681 milliseconds
'
END PEGGY OUTPUT
LoopInvariantCodeMotion
PEGGY OUTPUT:
b'+ Successfully added axiom file: axioms/java_operator_axioms.xml
+ Successfully added axiom file: axioms/java_util_axioms.xml
+ Successfully added axiom file: axioms/java_operator_costs.xml
+ Successfully added axiom file: axioms/java_arithmetic_axioms.xml
+ Loading class file LoopInvariantCodeMotion
+ Optimizing class LoopInvariantCodeMotion
   - Processing method <LoopInvariantCodeMotion: void <init>()>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 10 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 10
GLPKFormulation: Number of values: 10
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <LoopInvariantCodeMotion: void <init>()> SUCCESSFUL
      * Optimization took 311
      * PEG2PEGTIME 230
      * PBTIME 155
      * ENGINETIME 4
      * Optimization ratio 2000/2000 = 1.0
      * PEG-based Optimization ratio 2000/2000 = 1.0
   - Done processing method <LoopInvariantCodeMotion: void <init>()>
   - Processing method <LoopInvariantCodeMotion: void original(int,int)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine reached iteration bound of 1000 after 650 milliseconds
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 1276
GLPKFormulation: Number of values: 648
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <LoopInvariantCodeMotion: void original(int,int)> SUCCESSFUL
      * Optimization took 2684
      * PEG2PEGTIME 2628
      * PBTIME 1944
      * ENGINETIME 650
      * Optimization ratio 31459/31519 = 0.9980963863066722
      * PEG-based Optimization ratio 31459/31519 = 0.9980963863066722
   - Done processing method <LoopInvariantCodeMotion: void original(int,int)>
   - Processing method <LoopInvariantCodeMotion: void expected(int,int)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine reached iteration bound of 1000 after 349 milliseconds
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 1268
GLPKFormulation: Number of values: 648
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <LoopInvariantCodeMotion: void expected(int,int)> SUCCESSFUL
      * Optimization took 2091
      * PEG2PEGTIME 2054
      * PBTIME 1688
      * ENGINETIME 349
      * Optimization ratio 31459/31519 = 0.9980963863066722
      * PEG-based Optimization ratio 31459/31519 = 0.9980963863066722
   - Done processing method <LoopInvariantCodeMotion: void expected(int,int)>
+ Done optimizing LoopInvariantCodeMotion
+ Final results:
   - Skipped methods = 0
   - Buggy methods = 0
   - Total methods = 3
+ Fixing bytecode of method <LoopInvariantCodeMotion: void <init>()>
+ Fixing bytecode of method <LoopInvariantCodeMotion: void original(int,int)>
+ Fixing bytecode of method <LoopInvariantCodeMotion: void expected(int,int)>
+ Writing class back to optimized/LoopInvariantCodeMotion.class
+ Total optimization time = 5343 milliseconds
'
END PEGGY OUTPUT
ConstantFold
PEGGY OUTPUT:
b'+ Successfully added axiom file: axioms/java_operator_axioms.xml
+ Successfully added axiom file: axioms/java_util_axioms.xml
+ Successfully added axiom file: axioms/java_operator_costs.xml
+ Successfully added axiom file: axioms/java_arithmetic_axioms.xml
+ Loading class file ConstantFold
+ Optimizing class ConstantFold
   - Processing method <ConstantFold: void <init>()>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 10 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 10
GLPKFormulation: Number of values: 10
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <ConstantFold: void <init>()> SUCCESSFUL
      * Optimization took 288
      * PEG2PEGTIME 233
      * PBTIME 155
      * ENGINETIME 5
      * Optimization ratio 2000/2000 = 1.0
      * PEG-based Optimization ratio 2000/2000 = 1.0
   - Done processing method <ConstantFold: void <init>()>
   - Processing method <ConstantFold: int original()>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 12 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 9
GLPKFormulation: Number of values: 9
         @ Running solver
         @ No result from ILP solver
      * Original PEG chosen as output
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <ConstantFold: int original()> SUCCESSFUL
      * Optimization took 172
      * PEG2PEGTIME 167
      * PBTIME 128
      * ENGINETIME 10
   - Done processing method <ConstantFold: int original()>
+ Done optimizing ConstantFold
+ Final results:
   - Skipped methods = 0
   - Buggy methods = 0
   - Total methods = 2
+ Fixing bytecode of method <ConstantFold: void <init>()>
+ Fixing bytecode of method <ConstantFold: int original()>
+ Writing class back to optimized/ConstantFold.class
+ Total optimization time = 638 milliseconds
'
END PEGGY OUTPUT
LoopStrengthReduction
PEGGY OUTPUT:
b'+ Successfully added axiom file: axioms/java_operator_axioms.xml
+ Successfully added axiom file: axioms/java_util_axioms.xml
+ Successfully added axiom file: axioms/java_operator_costs.xml
+ Successfully added axiom file: axioms/java_arithmetic_axioms.xml
+ Loading class file LoopStrengthReduction
+ Optimizing class LoopStrengthReduction
   - Processing method <LoopStrengthReduction: void <init>()>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 10 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 10
GLPKFormulation: Number of values: 10
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <LoopStrengthReduction: void <init>()> SUCCESSFUL
      * Optimization took 312
      * PEG2PEGTIME 230
      * PBTIME 153
      * ENGINETIME 4
      * Optimization ratio 2000/2000 = 1.0
      * PEG-based Optimization ratio 2000/2000 = 1.0
   - Done processing method <LoopStrengthReduction: void <init>()>
   - Processing method <LoopStrengthReduction: void original()>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine reached iteration bound of 1000 after 1327 milliseconds
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 3241
GLPKFormulation: Number of values: 1287
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <LoopStrengthReduction: void original()> SUCCESSFUL
      * Optimization took 5053
      * PEG2PEGTIME 5021
      * PBTIME 3664
      * ENGINETIME 1327
      * Optimization ratio 31290/31490 = 0.9936487773896475
      * PEG-based Optimization ratio 31290/31490 = 0.9936487773896475
   - Done processing method <LoopStrengthReduction: void original()>
   - Processing method <LoopStrengthReduction: void expected()>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine reached iteration bound of 1000 after 1317 milliseconds
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 1796
GLPKFormulation: Number of values: 528
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <LoopStrengthReduction: void expected()> SUCCESSFUL
      * Optimization took 3669
      * PEG2PEGTIME 3650
      * PBTIME 2317
      * ENGINETIME 1317
      * Optimization ratio 31430/31430 = 1.0
      * PEG-based Optimization ratio 31430/31430 = 1.0
   - Done processing method <LoopStrengthReduction: void expected()>
+ Done optimizing LoopStrengthReduction
+ Final results:
   - Skipped methods = 0
   - Buggy methods = 0
   - Total methods = 3
+ Fixing bytecode of method <LoopStrengthReduction: void <init>()>
+ Fixing bytecode of method <LoopStrengthReduction: void original()>
+ Fixing bytecode of method <LoopStrengthReduction: void expected()>
+ Writing class back to optimized/LoopStrengthReduction.class
+ Total optimization time = 9272 milliseconds
'
END PEGGY OUTPUT
SimpleLoopUnswitch
PEGGY OUTPUT:
b'+ Successfully added axiom file: axioms/java_operator_axioms.xml
+ Successfully added axiom file: axioms/java_util_axioms.xml
+ Successfully added axiom file: axioms/java_operator_costs.xml
+ Successfully added axiom file: axioms/java_arithmetic_axioms.xml
+ Loading class file SimpleLoopUnswitch
+ Optimizing class SimpleLoopUnswitch
   - Processing method <SimpleLoopUnswitch: void <init>()>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 10 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 10
GLPKFormulation: Number of values: 10
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <SimpleLoopUnswitch: void <init>()> SUCCESSFUL
      * Optimization took 314
      * PEG2PEGTIME 232
      * PBTIME 153
      * ENGINETIME 5
      * Optimization ratio 2000/2000 = 1.0
      * PEG-based Optimization ratio 2000/2000 = 1.0
   - Done processing method <SimpleLoopUnswitch: void <init>()>
   - Processing method <SimpleLoopUnswitch: int original(int)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine reached iteration bound of 1000 after 529 milliseconds
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 1093
GLPKFormulation: Number of values: 729
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <SimpleLoopUnswitch: int original(int)> SUCCESSFUL
      * Optimization took 2756
      * PEG2PEGTIME 2682
      * PBTIME 2117
      * ENGINETIME 529
      * Optimization ratio 31435/31435 = 1.0
      * PEG-based Optimization ratio 31435/31435 = 1.0
   - Done processing method <SimpleLoopUnswitch: int original(int)>
+ Done optimizing SimpleLoopUnswitch
+ Final results:
   - Skipped methods = 0
   - Buggy methods = 0
   - Total methods = 2
+ Fixing bytecode of method <SimpleLoopUnswitch: void <init>()>
+ Fixing bytecode of method <SimpleLoopUnswitch: int original(int)>
+ Writing class back to optimized/SimpleLoopUnswitch.class
+ Total optimization time = 3276 milliseconds
'
END PEGGY OUTPUT
IfTrue
PEGGY OUTPUT:
b'+ Successfully added axiom file: axioms/java_operator_axioms.xml
+ Successfully added axiom file: axioms/java_util_axioms.xml
+ Successfully added axiom file: axioms/java_operator_costs.xml
+ Successfully added axiom file: axioms/java_arithmetic_axioms.xml
+ Loading class file IfTrue
+ Optimizing class IfTrue
   - Processing method <IfTrue: void <init>()>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 10 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 10
GLPKFormulation: Number of values: 10
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <IfTrue: void <init>()> SUCCESSFUL
      * Optimization took 309
      * PEG2PEGTIME 227
      * PBTIME 153
      * ENGINETIME 5
      * Optimization ratio 2000/2000 = 1.0
      * PEG-based Optimization ratio 2000/2000 = 1.0
   - Done processing method <IfTrue: void <init>()>
   - Processing method <IfTrue: int original(int)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 5 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 5
GLPKFormulation: Number of values: 5
         @ Running solver
         @ No result from ILP solver
      * Original PEG chosen as output
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <IfTrue: int original(int)> SUCCESSFUL
      * Optimization took 157
      * PEG2PEGTIME 152
      * PBTIME 124
      * ENGINETIME 1
   - Done processing method <IfTrue: int original(int)>
   - Processing method <IfTrue: int expected(int)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 5 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 5
GLPKFormulation: Number of values: 5
         @ Running solver
         @ No result from ILP solver
      * Original PEG chosen as output
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <IfTrue: int expected(int)> SUCCESSFUL
      * Optimization took 165
      * PEG2PEGTIME 158
      * PBTIME 125
      * ENGINETIME 2
   - Done processing method <IfTrue: int expected(int)>
+ Done optimizing IfTrue
+ Final results:
   - Skipped methods = 0
   - Buggy methods = 0
   - Total methods = 3
+ Fixing bytecode of method <IfTrue: void <init>()>
+ Fixing bytecode of method <IfTrue: int original(int)>
+ Fixing bytecode of method <IfTrue: int expected(int)>
+ Writing class back to optimized/IfTrue.class
+ Total optimization time = 849 milliseconds
'
END PEGGY OUTPUT
MultiVariableLoop
PEGGY OUTPUT:
b'+ Successfully added axiom file: axioms/java_operator_axioms.xml
+ Successfully added axiom file: axioms/java_util_axioms.xml
+ Successfully added axiom file: axioms/java_operator_costs.xml
+ Successfully added axiom file: axioms/java_arithmetic_axioms.xml
+ Loading class file MultiVariableLoop
+ Optimizing class MultiVariableLoop
   - Processing method <MultiVariableLoop: void <init>()>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 10 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 10
GLPKFormulation: Number of values: 10
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <MultiVariableLoop: void <init>()> SUCCESSFUL
      * Optimization took 286
      * PEG2PEGTIME 230
      * PBTIME 154
      * ENGINETIME 5
      * Optimization ratio 2000/2000 = 1.0
      * PEG-based Optimization ratio 2000/2000 = 1.0
   - Done processing method <MultiVariableLoop: void <init>()>
   - Processing method <MultiVariableLoop: int original(int)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine reached iteration bound of 1000 after 722 milliseconds
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 1163
GLPKFormulation: Number of values: 647
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <MultiVariableLoop: int original(int)> SUCCESSFUL
      * Optimization took 2965
      * PEG2PEGTIME 2914
      * PBTIME 2158
      * ENGINETIME 722
      * Optimization ratio 93750/93750 = 1.0
      * PEG-based Optimization ratio 93750/93750 = 1.0
   - Done processing method <MultiVariableLoop: int original(int)>
+ Done optimizing MultiVariableLoop
+ Final results:
   - Skipped methods = 0
   - Buggy methods = 0
   - Total methods = 2
+ Fixing bytecode of method <MultiVariableLoop: void <init>()>
+ Fixing bytecode of method <MultiVariableLoop: int original(int)>
+ Writing class back to optimized/MultiVariableLoop.class
+ Total optimization time = 3476 milliseconds
'
END PEGGY OUTPUT
BranchHoisting
PEGGY OUTPUT:
b'+ Successfully added axiom file: axioms/java_operator_axioms.xml
+ Successfully added axiom file: axioms/java_util_axioms.xml
+ Successfully added axiom file: axioms/java_operator_costs.xml
+ Successfully added axiom file: axioms/java_arithmetic_axioms.xml
+ Loading class file BranchHoisting
+ Optimizing class BranchHoisting
   - Processing method <BranchHoisting: void <init>()>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 10 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 10
GLPKFormulation: Number of values: 10
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <BranchHoisting: void <init>()> SUCCESSFUL
      * Optimization took 311
      * PEG2PEGTIME 229
      * PBTIME 154
      * ENGINETIME 5
      * Optimization ratio 2000/2000 = 1.0
      * PEG-based Optimization ratio 2000/2000 = 1.0
   - Done processing method <BranchHoisting: void <init>()>
   - Processing method <BranchHoisting: int original(int)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      ! Error processing method <BranchHoisting: int original(int)> [
         java.lang.IllegalStateException: Merging unequal values: [1100493726:gte(567229249,119698787), 1587713260:lte(119698787,567229249), 1365962294:False, 1171073130:gte(966912026,119698787), 1036999526:lte(119698787,966912026), 1191209411:gte(1440634406,1865869299), 2031741829:gte(377865944,1060002528), 1701850363:gte(1234769687,1082164432), 134986224:lte(1060002528,377865944), 891239180:gte(32655709,1665051819), 2107385320:gte(720106031,640401340), 894476390:gte(1877604187,1601340287), 1073299203:lte(640401340,720106031), 646975546:gte(32655709,1760981149), 18546089:gte(596850246,119698787), 1772367544:gte(1930610653,1060002528), 1763770983:gte(1877604187,640401340), 439598064:lte(119698787,596850246), 1923799383:Eval-1(2077961571,2120900660), 1933578107:Eval-1(912066286,2120900660), 839544566:Eval-1(588613627,2120900660), 583197405:Eval-1(159463950,2120900660), 1587861567:Eval-1(830607997,2120900660), 2110413789:Eval-1(1346054092,2120900660), 1663785666:Eval-1(1638497901,2120900660), 562494198:Eval-1(1244851731,2120900660), 2091766687:gte(1620646345,205407673), 687238923:Eval-1(1302680931,2120900660), 1301430804:Eval-1(1195383333,2120900660), 560662989:lte(1060002528,1930610653), 656755339:Eval-1(1767370218,2120900660), 2045393598:Eval-1(1101535878,2120900660), 1527660289:lte(1865869299,1440634406), 1609616313:Eval-1(1563117319,2120900660), 1645708409:gte(1865869299,1964788069), 755193169:gte(1082164432,1470415149), 64958094:lte(1082164432,1234769687), 2060048083:gte(352239029,1060002528), 1252995804:gte(1377368535,119698787), 1691185835:gte(2141493569,640401340), 914776110:lte(119698787,1377368535), 262231675:lte(1060002528,352239029), 1430343425:lte(640401340,2141493569), 1113354442:gte(388591093,1455136729), 13954102:gte(203593861,1601340287), 536385581:gte(982684805,1939642865), 314635482:gte(1342382160,1621791199), 1810476396:gte(2030563348,1082164432), 1486180206:gte(2053521084,119698787), 1469898532:lte(119698787,2053521084), 717690625:gte(1862676607,1060002528), 1724859291:gte(804301072,640401340), 1837502933:lte(1060002528,1862676607), 1883233238:lte(640401340,804301072), 1402575487:gte(1199454929,640401340), 1061309148:gte(1147015827,1060002528), 623698042:gte(254842853,1665051819), 1890611247:gte(1665051819,981813878), 928347844:lte(1665051819,32655709), 810181892:gte(1455136729,924638692), 184716048:gte(1601340287,2082939526), 1099011244:lte(1601340287,1877604187), 1221167360:lte(640401340,1877604187), 465618249:Eval-1(1574397161,2120900660), 2038637773:gte(1601340287,1553481063), 1305905475:gte(1455136729,1371570042), 1947976698:gte(1665051819,50268535), 764890953:lte(1760981149,32655709), 1014414236:gte(1440634406,640401340), 930526078:gte(274665351,119698787), 1129948032:gte(1620646345,1060002528), 1151898645:gte(1234769687,1760981149), 2128253962:lte(119698787,274665351), 610856819:Eval-1(1237716504,2120900660), 54618292:Eval-1(290655587,2120900660), 320333676:Eval-1(1460166564,2120900660), 1338424805:Eval-1(67525513,2120900660), 713394803:Eval-1(705020160,2120900660), 2121534730:Eval-1(1223575189,2120900660), 1267111885:Eval-1(2103609476,2120900660), 1789419492:Eval-1(39149205,2120900660), 982297488:Eval-1(1379376520,2120900660), 217383812:Eval-1(775392551,2120900660), 1947508524:Eval-1(1948035196,2120900660), 176639481:Eval-1(1911187497,2120900660), 1004327302:Eval-1(1001314963,2120900660), 383997341:Eval-1(241206528,2120900660), 1893694675:Eval-1(1370776333,2120900660), 773885252:Eval-1(376318593,2120900660), 367484681:Eval-1(1147766283,2120900660), 302022710:Eval-1(1095790443,2120900660), 1911921078:Eval-1(1554595632,2120900660), 20747507:Eval-1(1107925586,2120900660), 324299308:Eval-1(1993937627,2120900660), 535771559:Eval-1(1538072094,2120900660), 267340303:Eval-1(196967590,2120900660), 1396544829:Eval-1(232672330,2120900660), 1430410505:Eval-1(347641376,2120900660), 1831226719:Eval-1(242424130,2120900660), 105905726:lte(1455136729,388591093), 1844873641:gte(520269991,643710692), 372509656:gte(205407673,44387573), 337295443:lte(205407673,1620646345), 2143352317:gte(419955441,205407673), 1231528934:gte(1111110697,1455136729), 893957008:gte(1111110697,1908474226), 104414541:gte(460380035,1601340287), 180997683:gte(460380035,432135517), 944036831:Eval-1(404742859,2120900660), 695181757:lte(1601340287,203593861), 1003819407:lte(1060002528,1147015827), 559658620:Eval-1(1025041094,2120900660), 1874901094:Eval-1(977336579,2120900660), 1576341763:Eval-1(534633680,2120900660), 1466025830:Eval-1(2028357740,2120900660), 1631893935:gte(1167153927,1191536829), 2060842524:gte(1939642865,1394208467), 1164606624:lte(1939642865,982684805)], [1128088828:True]
         \tat eqsat.meminfer.engine.peg.CPEGValueManager.merge(CPEGValueManager.java:156)
         \tat eqsat.meminfer.engine.peg.CPEGValueManager.merge(CPEGValueManager.java:1)
         \tat eqsat.meminfer.engine.basic.EGraphManager$15.notify(EGraphManager.java:1001)
         \tat eqsat.meminfer.engine.basic.EGraphManager$15.notify(EGraphManager.java:1)
         \tat eqsat.meminfer.engine.basic.EGraphManager.postProcess(EGraphManager.java:963)
         \tat eqsat.meminfer.engine.basic.EGraphManager.process(EGraphManager.java:981)
         \tat peggy.analysis.BoundedEngineRunner.runEngine(BoundedEngineRunner.java:82)
         \tat peggy.optimize.PEG2PEGOptimizer.optimize(PEG2PEGOptimizer.java:87)
         \tat peggy.optimize.SingleStageOptimizer.optimize(SingleStageOptimizer.java:73)
         \tat peggy.optimize.java.Main.optimizeAll(Main.java:875)
         \tat peggy.optimize.java.Main.optimizeClass(Main.java:704)
         \tat peggy.optimize.java.Main.main(Main.java:2881)
         
      ]
      * Reverting to original method body
      * Optimization of method <BranchHoisting: int original(int)> FAILED
   - Processing method <BranchHoisting: int expected(int)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine reached iteration bound of 1000 after 543 milliseconds
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 1718
GLPKFormulation: Number of values: 817
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <BranchHoisting: int expected(int)> SUCCESSFUL
      * Optimization took 2884
      * PEG2PEGTIME 2847
      * PBTIME 2288
      * ENGINETIME 543
      * Optimization ratio 203/235 = 0.8638297872340426
      * PEG-based Optimization ratio 203/235 = 0.8638297872340426
   - Done processing method <BranchHoisting: int expected(int)>
+ Done optimizing BranchHoisting
+ Final results:
   - Skipped methods = 0
   - Buggy methods = 1
   - Total methods = 3
+ Fixing bytecode of method <BranchHoisting: void <init>()>
+ Fixing bytecode of method <BranchHoisting: int original(int)>
+ Fixing bytecode of method <BranchHoisting: int expected(int)>
+ Writing class back to optimized/BranchHoisting.class
+ Total optimization time = 4182 milliseconds
'
END PEGGY OUTPUT
Exception while parsing time
invalid literal for int() with base 10: ''
InfiniteLoop
PEGGY OUTPUT:
b'+ Successfully added axiom file: axioms/java_operator_axioms.xml
+ Successfully added axiom file: axioms/java_util_axioms.xml
+ Successfully added axiom file: axioms/java_operator_costs.xml
+ Successfully added axiom file: axioms/java_arithmetic_axioms.xml
+ Loading class file InfiniteLoop
+ Optimizing class InfiniteLoop
   - Processing method <InfiniteLoop: void <init>()>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 10 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 10
GLPKFormulation: Number of values: 10
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <InfiniteLoop: void <init>()> SUCCESSFUL
      * Optimization took 312
      * PEG2PEGTIME 230
      * PBTIME 156
      * ENGINETIME 4
      * Optimization ratio 2000/2000 = 1.0
      * PEG-based Optimization ratio 2000/2000 = 1.0
   - Done processing method <InfiniteLoop: void <init>()>
   - Processing method <InfiniteLoop: void main(java.lang.String[])>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 9 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 9
GLPKFormulation: Number of values: 9
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <InfiniteLoop: void main(java.lang.String[])> SUCCESSFUL
      * Optimization took 165
      * PEG2PEGTIME 159
      * PBTIME 132
      * ENGINETIME 2
      * Optimization ratio 2000/2000 = 1.0
      * PEG-based Optimization ratio 2000/2000 = 1.0
   - Done processing method <InfiniteLoop: void main(java.lang.String[])>
   - Processing method <InfiniteLoop: int original()>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine reached iteration bound of 1000 after 1131 milliseconds
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 787
GLPKFormulation: Number of values: 134
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      ! Error processing method <InfiniteLoop: int original()> [
         java.lang.RuntimeException: Bad CFG: Should never happen
         \tat eqsat.revert.RevertCFG.removeEmptyFallBlocks(RevertCFG.java:401)
         \tat eqsat.revert.RevertCFG.simplify(RevertCFG.java:311)
         \tat eqsat.revert.CFGReverter.<init>(CFGReverter.java:38)
         \tat peggy.optimize.SingleStageOptimizer.optimize(SingleStageOptimizer.java:104)
         \tat peggy.optimize.java.Main.optimizeAll(Main.java:875)
         \tat peggy.optimize.java.Main.optimizeClass(Main.java:704)
         \tat peggy.optimize.java.Main.main(Main.java:2881)
         
      ]
      * Reverting to original method body
      * Optimization of method <InfiniteLoop: int original()> FAILED
+ Done optimizing InfiniteLoop
+ Final results:
   - Skipped methods = 0
   - Buggy methods = 1
   - Total methods = 3
+ Fixing bytecode of method <InfiniteLoop: void <init>()>
+ Fixing bytecode of method <InfiniteLoop: void main(java.lang.String[])>
+ Fixing bytecode of method <InfiniteLoop: int original()>
+ Writing class back to optimized/InfiniteLoop.class
+ Total optimization time = 2527 milliseconds
'
END PEGGY OUTPUT
LoopBasedCodeMotion
PEGGY OUTPUT:
b'+ Successfully added axiom file: axioms/java_operator_axioms.xml
+ Successfully added axiom file: axioms/java_util_axioms.xml
+ Successfully added axiom file: axioms/java_operator_costs.xml
+ Successfully added axiom file: axioms/java_arithmetic_axioms.xml
+ Loading class file LoopBasedCodeMotion
+ Optimizing class LoopBasedCodeMotion
   - Processing method <LoopBasedCodeMotion: void <init>()>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 10 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 10
GLPKFormulation: Number of values: 10
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <LoopBasedCodeMotion: void <init>()> SUCCESSFUL
      * Optimization took 312
      * PEG2PEGTIME 230
      * PBTIME 153
      * ENGINETIME 4
      * Optimization ratio 2000/2000 = 1.0
      * PEG-based Optimization ratio 2000/2000 = 1.0
   - Done processing method <LoopBasedCodeMotion: void <init>()>
   - Processing method <LoopBasedCodeMotion: int original()>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine reached iteration bound of 1000 after 1450 milliseconds
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 2977
GLPKFormulation: Number of values: 1308
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <LoopBasedCodeMotion: int original()> SUCCESSFUL
      * Optimization took 4601
      * PEG2PEGTIME 4579
      * PBTIME 3097
      * ENGINETIME 1450
      * Optimization ratio 190/210 = 0.9047619047619048
      * PEG-based Optimization ratio 190/210 = 0.9047619047619048
   - Done processing method <LoopBasedCodeMotion: int original()>
   - Processing method <LoopBasedCodeMotion: int expected()>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine reached iteration bound of 1000 after 758 milliseconds
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 726
GLPKFormulation: Number of values: 126
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <LoopBasedCodeMotion: int expected()> SUCCESSFUL
      * Optimization took 1280
      * PEG2PEGTIME 1266
      * PBTIME 492
      * ENGINETIME 758
      * Optimization ratio 190/190 = 1.0
      * PEG-based Optimization ratio 190/190 = 1.0
   - Done processing method <LoopBasedCodeMotion: int expected()>
+ Done optimizing LoopBasedCodeMotion
+ Final results:
   - Skipped methods = 0
   - Buggy methods = 0
   - Total methods = 3
+ Fixing bytecode of method <LoopBasedCodeMotion: void <init>()>
+ Fixing bytecode of method <LoopBasedCodeMotion: int original()>
+ Fixing bytecode of method <LoopBasedCodeMotion: int expected()>
+ Writing class back to optimized/LoopBasedCodeMotion.class
+ Total optimization time = 6429 milliseconds
'
END PEGGY OUTPUT
FunctionInlining
PEGGY OUTPUT:
b'+ Successfully added axiom file: axioms/java_operator_axioms.xml
+ Successfully added axiom file: axioms/java_util_axioms.xml
+ Successfully added axiom file: axioms/java_operator_costs.xml
+ Successfully added axiom file: axioms/java_arithmetic_axioms.xml
+ Loading class file FunctionInlining
+ Optimizing class FunctionInlining
   - Processing method <FunctionInlining: void <init>()>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 10 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 10
GLPKFormulation: Number of values: 10
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <FunctionInlining: void <init>()> SUCCESSFUL
      * Optimization took 310
      * PEG2PEGTIME 230
      * PBTIME 154
      * ENGINETIME 5
      * Optimization ratio 2000/2000 = 1.0
      * PEG-based Optimization ratio 2000/2000 = 1.0
   - Done processing method <FunctionInlining: void <init>()>
   - Processing method <FunctionInlining: int foo()>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 5 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 5
GLPKFormulation: Number of values: 5
         @ Running solver
         @ No result from ILP solver
      * Original PEG chosen as output
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <FunctionInlining: int foo()> SUCCESSFUL
      * Optimization took 157
      * PEG2PEGTIME 153
      * PBTIME 126
      * ENGINETIME 1
   - Done processing method <FunctionInlining: int foo()>
   - Processing method <FunctionInlining: int original(int)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 13 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 13
GLPKFormulation: Number of values: 12
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <FunctionInlining: int original(int)> SUCCESSFUL
      * Optimization took 176
      * PEG2PEGTIME 166
      * PBTIME 134
      * ENGINETIME 11
      * Optimization ratio 3004/3004 = 1.0
      * PEG-based Optimization ratio 3004/3004 = 1.0
   - Done processing method <FunctionInlining: int original(int)>
   - Processing method <FunctionInlining: int expected(int)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 8 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 8
GLPKFormulation: Number of values: 7
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <FunctionInlining: int expected(int)> SUCCESSFUL
      * Optimization took 176
      * PEG2PEGTIME 168
      * PBTIME 129
      * ENGINETIME 5
      * Optimization ratio 4/4 = 1.0
      * PEG-based Optimization ratio 4/4 = 1.0
   - Done processing method <FunctionInlining: int expected(int)>
+ Done optimizing FunctionInlining
+ Final results:
   - Skipped methods = 0
   - Buggy methods = 0
   - Total methods = 4
+ Fixing bytecode of method <FunctionInlining: void <init>()>
+ Fixing bytecode of method <FunctionInlining: int foo()>
+ Fixing bytecode of method <FunctionInlining: int original(int)>
+ Fixing bytecode of method <FunctionInlining: int expected(int)>
+ Writing class back to optimized/FunctionInlining.class
+ Total optimization time = 1048 milliseconds
'
END PEGGY OUTPUT
InfiniteEffectfulLoop
PEGGY OUTPUT:
b'+ Successfully added axiom file: axioms/java_operator_axioms.xml
+ Successfully added axiom file: axioms/java_util_axioms.xml
+ Successfully added axiom file: axioms/java_operator_costs.xml
+ Successfully added axiom file: axioms/java_arithmetic_axioms.xml
+ Loading class file InfiniteEffectfulLoop
+ Optimizing class InfiniteEffectfulLoop
   - Processing method <InfiniteEffectfulLoop: void <init>()>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 10 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 10
GLPKFormulation: Number of values: 10
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <InfiniteEffectfulLoop: void <init>()> SUCCESSFUL
      * Optimization took 286
      * PEG2PEGTIME 230
      * PBTIME 156
      * ENGINETIME 4
      * Optimization ratio 2000/2000 = 1.0
      * PEG-based Optimization ratio 2000/2000 = 1.0
   - Done processing method <InfiniteEffectfulLoop: void <init>()>
   - Processing method <InfiniteEffectfulLoop: void main(java.lang.String[])>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 9 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 9
GLPKFormulation: Number of values: 9
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <InfiniteEffectfulLoop: void main(java.lang.String[])> SUCCESSFUL
      * Optimization took 164
      * PEG2PEGTIME 160
      * PBTIME 132
      * ENGINETIME 2
      * Optimization ratio 2000/2000 = 1.0
      * PEG-based Optimization ratio 2000/2000 = 1.0
   - Done processing method <InfiniteEffectfulLoop: void main(java.lang.String[])>
   - Processing method <InfiniteEffectfulLoop: int original()>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine reached iteration bound of 1000 after 443 milliseconds
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 1043
GLPKFormulation: Number of values: 716
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      ! Error processing method <InfiniteEffectfulLoop: int original()> [
         java.lang.RuntimeException: Bad CFG: Should never happen
         \tat eqsat.revert.RevertCFG.removeEmptyFallBlocks(RevertCFG.java:401)
         \tat eqsat.revert.RevertCFG.simplify(RevertCFG.java:311)
         \tat eqsat.revert.CFGReverter.<init>(CFGReverter.java:38)
         \tat peggy.optimize.SingleStageOptimizer.optimize(SingleStageOptimizer.java:104)
         \tat peggy.optimize.java.Main.optimizeAll(Main.java:875)
         \tat peggy.optimize.java.Main.optimizeClass(Main.java:704)
         \tat peggy.optimize.java.Main.main(Main.java:2881)
         
      ]
      * Reverting to original method body
      * Optimization of method <InfiniteEffectfulLoop: int original()> FAILED
+ Done optimizing InfiniteEffectfulLoop
+ Final results:
   - Skipped methods = 0
   - Buggy methods = 1
   - Total methods = 3
+ Fixing bytecode of method <InfiniteEffectfulLoop: void <init>()>
+ Fixing bytecode of method <InfiniteEffectfulLoop: void main(java.lang.String[])>
+ Fixing bytecode of method <InfiniteEffectfulLoop: int original()>
+ Writing class back to optimized/InfiniteEffectfulLoop.class
+ Total optimization time = 1984 milliseconds
'
END PEGGY OUTPUT
LoopUnroll
PEGGY OUTPUT:
b'+ Successfully added axiom file: axioms/java_operator_axioms.xml
+ Successfully added axiom file: axioms/java_util_axioms.xml
+ Successfully added axiom file: axioms/java_operator_costs.xml
+ Successfully added axiom file: axioms/java_arithmetic_axioms.xml
+ Loading class file LoopUnroll
+ Optimizing class LoopUnroll
   - Processing method <LoopUnroll: void <init>()>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 10 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 10
GLPKFormulation: Number of values: 10
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <LoopUnroll: void <init>()> SUCCESSFUL
      * Optimization took 289
      * PEG2PEGTIME 232
      * PBTIME 154
      * ENGINETIME 5
      * Optimization ratio 2000/2000 = 1.0
      * PEG-based Optimization ratio 2000/2000 = 1.0
   - Done processing method <LoopUnroll: void <init>()>
   - Processing method <LoopUnroll: int original(int)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine reached iteration bound of 1000 after 1045 milliseconds
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 721
GLPKFormulation: Number of values: 123
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <LoopUnroll: int original(int)> SUCCESSFUL
      * Optimization took 1684
      * PEG2PEGTIME 1655
      * PBTIME 581
      * ENGINETIME 1046
      * Optimization ratio 190/190 = 1.0
      * PEG-based Optimization ratio 190/190 = 1.0
   - Done processing method <LoopUnroll: int original(int)>
   - Processing method <LoopUnroll: int expected(int)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 5 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 5
GLPKFormulation: Number of values: 5
         @ Running solver
         @ No result from ILP solver
      * Original PEG chosen as output
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <LoopUnroll: int expected(int)> SUCCESSFUL
      * Optimization took 172
      * PEG2PEGTIME 167
      * PBTIME 143
      * ENGINETIME 0
   - Done processing method <LoopUnroll: int expected(int)>
+ Done optimizing LoopUnroll
+ Final results:
   - Skipped methods = 0
   - Buggy methods = 0
   - Total methods = 3
+ Fixing bytecode of method <LoopUnroll: void <init>()>
+ Fixing bytecode of method <LoopUnroll: int original(int)>
+ Fixing bytecode of method <LoopUnroll: int expected(int)>
+ Writing class back to optimized/LoopUnroll.class
+ Total optimization time = 2385 milliseconds
'
END PEGGY OUTPUT
SeparateLoops
PEGGY OUTPUT:
b'+ Successfully added axiom file: axioms/java_operator_axioms.xml
+ Successfully added axiom file: axioms/java_util_axioms.xml
+ Successfully added axiom file: axioms/java_operator_costs.xml
+ Successfully added axiom file: axioms/java_arithmetic_axioms.xml
+ Loading class file SeparateLoops
+ Optimizing class SeparateLoops
   - Processing method <SeparateLoops: void <init>()>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 10 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 10
GLPKFormulation: Number of values: 10
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <SeparateLoops: void <init>()> SUCCESSFUL
      * Optimization took 310
      * PEG2PEGTIME 230
      * PBTIME 156
      * ENGINETIME 4
      * Optimization ratio 2000/2000 = 1.0
      * PEG-based Optimization ratio 2000/2000 = 1.0
   - Done processing method <SeparateLoops: void <init>()>
   - Processing method <SeparateLoops: int interrelated(int)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine reached iteration bound of 1000 after 1060 milliseconds
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 2228
GLPKFormulation: Number of values: 730
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <SeparateLoops: int interrelated(int)> SUCCESSFUL
      * Optimization took 2871
      * PEG2PEGTIME 2826
      * PBTIME 1734
      * ENGINETIME 1060
      * Optimization ratio 524/524 = 1.0
      * PEG-based Optimization ratio 524/524 = 1.0
   - Done processing method <SeparateLoops: int interrelated(int)>
   - Processing method <SeparateLoops: void unrelated(int)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine reached iteration bound of 1000 after 1336 milliseconds
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 2099
GLPKFormulation: Number of values: 652
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <SeparateLoops: void unrelated(int)> SUCCESSFUL
      * Optimization took 2684
      * PEG2PEGTIME 2654
      * PBTIME 1300
      * ENGINETIME 1336
      * Optimization ratio 6530/6530 = 1.0
      * PEG-based Optimization ratio 6530/6530 = 1.0
   - Done processing method <SeparateLoops: void unrelated(int)>
+ Done optimizing SeparateLoops
+ Final results:
   - Skipped methods = 0
   - Buggy methods = 0
   - Total methods = 3
+ Fixing bytecode of method <SeparateLoops: void <init>()>
+ Fixing bytecode of method <SeparateLoops: int interrelated(int)>
+ Fixing bytecode of method <SeparateLoops: void unrelated(int)>
+ Writing class back to optimized/SeparateLoops.class
+ Total optimization time = 6136 milliseconds
'
END PEGGY OUTPUT
LoopStrengthReductionModified
PEGGY OUTPUT:
b'+ Successfully added axiom file: axioms/java_operator_axioms.xml
+ Successfully added axiom file: axioms/java_util_axioms.xml
+ Successfully added axiom file: axioms/java_operator_costs.xml
+ Successfully added axiom file: axioms/java_arithmetic_axioms.xml
+ Loading class file LoopStrengthReductionModified
+ Optimizing class LoopStrengthReductionModified
   - Processing method <LoopStrengthReductionModified: void <init>()>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 10 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 10
GLPKFormulation: Number of values: 10
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <LoopStrengthReductionModified: void <init>()> SUCCESSFUL
      * Optimization took 313
      * PEG2PEGTIME 232
      * PBTIME 153
      * ENGINETIME 5
      * Optimization ratio 2000/2000 = 1.0
      * PEG-based Optimization ratio 2000/2000 = 1.0
   - Done processing method <LoopStrengthReductionModified: void <init>()>
   - Processing method <LoopStrengthReductionModified: void original()>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine reached iteration bound of 1000 after 932 milliseconds
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 2059
GLPKFormulation: Number of values: 1373
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <LoopStrengthReductionModified: void original()> SUCCESSFUL
      * Optimization took 8616
      * PEG2PEGTIME 8566
      * PBTIME 7601
      * ENGINETIME 932
      * Optimization ratio 31640/31720 = 0.9974779319041615
      * PEG-based Optimization ratio 31640/31720 = 0.9974779319041615
   - Done processing method <LoopStrengthReductionModified: void original()>
   - Processing method <LoopStrengthReductionModified: void expected()>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine reached iteration bound of 1000 after 516 milliseconds
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 2270
GLPKFormulation: Number of values: 1142
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <LoopStrengthReductionModified: void expected()> SUCCESSFUL
      * Optimization took 2539
      * PEG2PEGTIME 2503
      * PBTIME 1970
      * ENGINETIME 516
      * Optimization ratio 31520/31520 = 1.0
      * PEG-based Optimization ratio 31520/31520 = 1.0
   - Done processing method <LoopStrengthReductionModified: void expected()>
+ Done optimizing LoopStrengthReductionModified
+ Final results:
   - Skipped methods = 0
   - Buggy methods = 0
   - Total methods = 3
+ Fixing bytecode of method <LoopStrengthReductionModified: void <init>()>
+ Fixing bytecode of method <LoopStrengthReductionModified: void original()>
+ Fixing bytecode of method <LoopStrengthReductionModified: void expected()>
+ Writing class back to optimized/LoopStrengthReductionModified.class
+ Total optimization time = 11725 milliseconds
'
END PEGGY OUTPUT
Raytracer
Command timed out
java -Xmx2000m -cp .:peggy_1.0.jar:benchmark/passing/ peggy.optimize.java.Main -O2 Raytracer -activate livsr:binop:constant -glpkPath "/glpk-5.0/examples/glpsol" -pb glpk -axioms axioms/java_arithmetic_axioms.xml:axioms/java_operator_axioms.xml:axioms/java_operator_costs.xml:axioms/java_util_axioms.xml -tmpFolder tmp
PEGGY OUTPUT:
b'+ Successfully added axiom file: axioms/java_operator_axioms.xml
+ Successfully added axiom file: axioms/java_util_axioms.xml
+ Successfully added axiom file: axioms/java_operator_costs.xml
+ Successfully added axiom file: axioms/java_arithmetic_axioms.xml
+ Loading class file Raytracer
+ Optimizing class Raytracer
   - Processing method <Raytracer: void <init>()>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 10 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 10
GLPKFormulation: Number of values: 10
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <Raytracer: void <init>()> SUCCESSFUL
      * Optimization took 315
      * PEG2PEGTIME 233
      * PBTIME 155
      * ENGINETIME 4
      * Optimization ratio 2000/2000 = 1.0
      * PEG-based Optimization ratio 2000/2000 = 1.0
   - Done processing method <Raytracer: void <init>()>
   - Processing method <Raytracer: void main(double,double,double,double,double)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine reached iteration bound of 1000 after 436 milliseconds
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 788
GLPKFormulation: Number of values: 1223
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <Raytracer: void main(double,double,double,double,double)> SUCCESSFUL
      * Optimization took 9631
      * PEG2PEGTIME 9389
      * PBTIME 8899
      * ENGINETIME 436
      * Optimization ratio 2058440/2058440 = 1.0
      * PEG-based Optimization ratio 2058440/2058440 = 1.0
   - Done processing method <Raytracer: void main(double,double,double,double,double)>
   - Processing method <Raytracer: double[][] sampleRay(double,double)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 143 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 143
GLPKFormulation: Number of values: 143
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <Raytracer: double[][] sampleRay(double,double)> SUCCESSFUL
      * Optimization took 256
      * PEG2PEGTIME 220
      * PBTIME 184
      * ENGINETIME 7
      * Optimization ratio 43402/43402 = 1.0
      * PEG-based Optimization ratio 43402/43402 = 1.0
   - Done processing method <Raytracer: double[][] sampleRay(double,double)>
   - Processing method <Raytracer: boolean bboxRayIntersect(double[][],double[][])>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 177 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 177
GLPKFormulation: Number of values: 175
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <Raytracer: boolean bboxRayIntersect(double[][],double[][])> SUCCESSFUL
      * Optimization took 273
      * PEG2PEGTIME 207
      * PBTIME 179
      * ENGINETIME 10
      * Optimization ratio 23954/23954 = 1.0
      * PEG-based Optimization ratio 23954/23954 = 1.0
   - Done processing method <Raytracer: boolean bboxRayIntersect(double[][],double[][])>
   - Processing method <Raytracer: double[] vecSubtract(double[],double[])>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 41 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 41
GLPKFormulation: Number of values: 41
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <Raytracer: double[] vecSubtract(double[],double[])> SUCCESSFUL
      * Optimization took 180
      * PEG2PEGTIME 169
      * PBTIME 149
      * ENGINETIME 1
      * Optimization ratio 1912/1912 = 1.0
      * PEG-based Optimization ratio 1912/1912 = 1.0
   - Done processing method <Raytracer: double[] vecSubtract(double[],double[])>
   - Processing method <Raytracer: double[] vecAdd(double[],double[])>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 44 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 44
GLPKFormulation: Number of values: 41
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <Raytracer: double[] vecAdd(double[],double[])> SUCCESSFUL
      * Optimization took 196
      * PEG2PEGTIME 186
      * PBTIME 150
      * ENGINETIME 5
      * Optimization ratio 1912/1912 = 1.0
      * PEG-based Optimization ratio 1912/1912 = 1.0
   - Done processing method <Raytracer: double[] vecAdd(double[],double[])>
   - Processing method <Raytracer: double[] vecScale(double[],double)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 35 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 35
GLPKFormulation: Number of values: 32
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <Raytracer: double[] vecScale(double[],double)> SUCCESSFUL
      * Optimization took 189
      * PEG2PEGTIME 181
      * PBTIME 146
      * ENGINETIME 4
      * Optimization ratio 1660/1660 = 1.0
      * PEG-based Optimization ratio 1660/1660 = 1.0
   - Done processing method <Raytracer: double[] vecScale(double[],double)>
   - Processing method <Raytracer: double[] vecCross(double[],double[])>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 71 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 71
GLPKFormulation: Number of values: 65
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <Raytracer: double[] vecCross(double[],double[])> SUCCESSFUL
      * Optimization took 210
      * PEG2PEGTIME 194
      * PBTIME 156
      * ENGINETIME 7
      * Optimization ratio 2632/2632 = 1.0
      * PEG-based Optimization ratio 2632/2632 = 1.0
   - Done processing method <Raytracer: double[] vecCross(double[],double[])>
   - Processing method <Raytracer: double abs(double)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 12 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 12
GLPKFormulation: Number of values: 11
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <Raytracer: double abs(double)> SUCCESSFUL
      * Optimization took 178
      * PEG2PEGTIME 171
      * PBTIME 140
      * ENGINETIME 2
      * Optimization ratio 47/47 = 1.0
      * PEG-based Optimization ratio 47/47 = 1.0
   - Done processing method <Raytracer: double abs(double)>
   - Processing method <Raytracer: double sqrt(double)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine reached iteration bound of 1000 after 426 milliseconds
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 1141
GLPKFormulation: Number of values: 807
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <Raytracer: double sqrt(double)> SUCCESSFUL
      * Optimization took 6708
      * PEG2PEGTIME 6678
      * PBTIME 6222
      * ENGINETIME 426
      * Optimization ratio 21920/21920 = 1.0
      * PEG-based Optimization ratio 21920/21920 = 1.0
   - Done processing method <Raytracer: double sqrt(double)>
   - Processing method <Raytracer: double vecLength(double[])>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 49 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 49
GLPKFormulation: Number of values: 38
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <Raytracer: double vecLength(double[])> SUCCESSFUL
      * Optimization took 201
      * PEG2PEGTIME 193
      * PBTIME 162
      * ENGINETIME 3
      * Optimization ratio 2668/2668 = 1.0
      * PEG-based Optimization ratio 2668/2668 = 1.0
   - Done processing method <Raytracer: double vecLength(double[])>
   - Processing method <Raytracer: double[] vecNormalize(double[])>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 36 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 36
GLPKFormulation: Number of values: 36
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <Raytracer: double[] vecNormalize(double[])> SUCCESSFUL
      * Optimization took 200
      * PEG2PEGTIME 191
      * PBTIME 156
      * ENGINETIME 3
      * Optimization ratio 3720/3720 = 1.0
      * PEG-based Optimization ratio 3720/3720 = 1.0
   - Done processing method <Raytracer: double[] vecNormalize(double[])>
   - Processing method <Raytracer: double dot(double[],double[])>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 45 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 45
GLPKFormulation: Number of values: 34
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <Raytracer: double dot(double[],double[])> SUCCESSFUL
      * Optimization took 196
      * PEG2PEGTIME 188
      * PBTIME 156
      * ENGINETIME 7
      * Optimization ratio 668/668 = 1.0
      * PEG-based Optimization ratio 668/668 = 1.0
   - Done processing method <Raytracer: double dot(double[],double[])>
   - Processing method <Raytracer: void buildBVH(double[][][],long[][],double[][][],long[],long[])>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine reached iteration bound of 1000 after 292 milliseconds
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 1154
GLPKFormulation: Number of values: 1404
         @ Running solver
'
END PEGGY OUTPUT
ConditionalConstantFolding
PEGGY OUTPUT:
b'+ Successfully added axiom file: axioms/java_operator_axioms.xml
+ Successfully added axiom file: axioms/java_util_axioms.xml
+ Successfully added axiom file: axioms/java_operator_costs.xml
+ Successfully added axiom file: axioms/java_arithmetic_axioms.xml
+ Loading class file ConditionalConstantFolding
+ Optimizing class ConditionalConstantFolding
   - Processing method <ConditionalConstantFolding: void <init>()>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 10 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 10
GLPKFormulation: Number of values: 10
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <ConditionalConstantFolding: void <init>()> SUCCESSFUL
      * Optimization took 306
      * PEG2PEGTIME 225
      * PBTIME 153
      * ENGINETIME 4
      * Optimization ratio 2000/2000 = 1.0
      * PEG-based Optimization ratio 2000/2000 = 1.0
   - Done processing method <ConditionalConstantFolding: void <init>()>
   - Processing method <ConditionalConstantFolding: int original(int)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 16 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 16
GLPKFormulation: Number of values: 14
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <ConditionalConstantFolding: int original(int)> SUCCESSFUL
      * Optimization took 203
      * PEG2PEGTIME 178
      * PBTIME 137
      * ENGINETIME 12
      * Optimization ratio 50/50 = 1.0
      * PEG-based Optimization ratio 50/50 = 1.0
   - Done processing method <ConditionalConstantFolding: int original(int)>
   - Processing method <ConditionalConstantFolding: int expected()>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 5 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 5
GLPKFormulation: Number of values: 5
         @ Running solver
         @ No result from ILP solver
      * Original PEG chosen as output
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <ConditionalConstantFolding: int expected()> SUCCESSFUL
      * Optimization took 150
      * PEG2PEGTIME 146
      * PBTIME 125
      * ENGINETIME 1
   - Done processing method <ConditionalConstantFolding: int expected()>
+ Done optimizing ConditionalConstantFolding
+ Final results:
   - Skipped methods = 0
   - Buggy methods = 0
   - Total methods = 3
+ Fixing bytecode of method <ConditionalConstantFolding: void <init>()>
+ Fixing bytecode of method <ConditionalConstantFolding: int original(int)>
+ Fixing bytecode of method <ConditionalConstantFolding: int expected()>
+ Writing class back to optimized/ConditionalConstantFolding.class
+ Total optimization time = 888 milliseconds
'
END PEGGY OUTPUT
LoopPeeling
PEGGY OUTPUT:
b'+ Successfully added axiom file: axioms/java_operator_axioms.xml
+ Successfully added axiom file: axioms/java_util_axioms.xml
+ Successfully added axiom file: axioms/java_operator_costs.xml
+ Successfully added axiom file: axioms/java_arithmetic_axioms.xml
+ Loading class file LoopPeeling
+ Optimizing class LoopPeeling
   - Processing method <LoopPeeling: void <init>()>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 10 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 10
GLPKFormulation: Number of values: 10
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <LoopPeeling: void <init>()> SUCCESSFUL
      * Optimization took 309
      * PEG2PEGTIME 228
      * PBTIME 153
      * ENGINETIME 5
      * Optimization ratio 2000/2000 = 1.0
      * PEG-based Optimization ratio 2000/2000 = 1.0
   - Done processing method <LoopPeeling: void <init>()>
   - Processing method <LoopPeeling: int original(int)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine reached iteration bound of 1000 after 1321 milliseconds
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 1842
GLPKFormulation: Number of values: 203
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <LoopPeeling: int original(int)> SUCCESSFUL
      * Optimization took 2661
      * PEG2PEGTIME 2627
      * PBTIME 1274
      * ENGINETIME 1321
      * Optimization ratio 330/330 = 1.0
      * PEG-based Optimization ratio 330/330 = 1.0
   - Done processing method <LoopPeeling: int original(int)>
   - Processing method <LoopPeeling: int expected(int)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine reached iteration bound of 1000 after 1309 milliseconds
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 1427
GLPKFormulation: Number of values: 155
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <LoopPeeling: int expected(int)> SUCCESSFUL
      * Optimization took 2818
      * PEG2PEGTIME 2782
      * PBTIME 1456
      * ENGINETIME 1310
      * Optimization ratio 335/335 = 1.0
      * PEG-based Optimization ratio 335/335 = 1.0
   - Done processing method <LoopPeeling: int expected(int)>
+ Done optimizing LoopPeeling
+ Final results:
   - Skipped methods = 0
   - Buggy methods = 0
   - Total methods = 3
+ Fixing bytecode of method <LoopPeeling: void <init>()>
+ Fixing bytecode of method <LoopPeeling: int original(int)>
+ Fixing bytecode of method <LoopPeeling: int expected(int)>
+ Writing class back to optimized/LoopPeeling.class
+ Total optimization time = 6029 milliseconds
'
END PEGGY OUTPUT
BENCHMARKING benchmark/failing/
UnswitchedLoop
PEGGY OUTPUT:
b'+ Successfully added axiom file: axioms/java_operator_axioms.xml
+ Successfully added axiom file: axioms/java_util_axioms.xml
+ Successfully added axiom file: axioms/java_operator_costs.xml
+ Successfully added axiom file: axioms/java_arithmetic_axioms.xml
+ Loading class file UnswitchedLoop
+ Optimizing class UnswitchedLoop
   - Processing method <UnswitchedLoop: void <init>()>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 10 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 10
GLPKFormulation: Number of values: 10
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <UnswitchedLoop: void <init>()> SUCCESSFUL
      * Optimization took 310
      * PEG2PEGTIME 229
      * PBTIME 151
      * ENGINETIME 4
      * Optimization ratio 2000/2000 = 1.0
      * PEG-based Optimization ratio 2000/2000 = 1.0
   - Done processing method <UnswitchedLoop: void <init>()>
   - Processing method <UnswitchedLoop: int expected(int)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine reached iteration bound of 1000 after 555 milliseconds
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 1268
GLPKFormulation: Number of values: 815
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <UnswitchedLoop: int expected(int)> SUCCESSFUL
      * Optimization took 3229
      * PEG2PEGTIME 3152
      * PBTIME 2565
      * ENGINETIME 555
      * Optimization ratio 31395/31399 = 0.9998726074078792
      * PEG-based Optimization ratio 31395/31399 = 0.9998726074078792
   - Done processing method <UnswitchedLoop: int expected(int)>
+ Done optimizing UnswitchedLoop
+ Final results:
   - Skipped methods = 0
   - Buggy methods = 0
   - Total methods = 2
+ Fixing bytecode of method <UnswitchedLoop: void <init>()>
+ Fixing bytecode of method <UnswitchedLoop: int expected(int)>
+ Writing class back to optimized/UnswitchedLoop.class
+ Total optimization time = 3756 milliseconds
'
END PEGGY OUTPUT
BENCHMARKING uninlined-spec/compress/
Decompressor
PEGGY OUTPUT:
b'+ Successfully added axiom file: axioms/java_operator_axioms.xml
+ Successfully added axiom file: axioms/java_util_axioms.xml
+ Successfully added axiom file: axioms/java_operator_costs.xml
+ Successfully added axiom file: axioms/java_arithmetic_axioms.xml
+ Loading class file Decompressor
+ Optimizing class Decompressor
   - Processing method <Decompressor: void <init>(InputBuffer,OutputBuffer)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 223 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 223
GLPKFormulation: Number of values: 214
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <Decompressor: void <init>(InputBuffer,OutputBuffer)> SUCCESSFUL
      * Optimization took 628
      * PEG2PEGTIME 440
      * PBTIME 268
      * ENGINETIME 82
      * Optimization ratio 59046/59046 = 1.0
      * PEG-based Optimization ratio 59046/59046 = 1.0
   - Done processing method <Decompressor: void <init>(InputBuffer,OutputBuffer)>
   - Processing method <Decompressor: void decompress()>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine reached iteration bound of 1000 after 377 milliseconds
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 575
GLPKFormulation: Number of values: 946
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      ! Error processing method <Decompressor: void decompress()> [
         java.lang.StackOverflowError
         \tat eqsat.revert.ReversionGraph$MultiVertex.getChildren(ReversionGraph.java:714)
         \tat eqsat.revert.Block$8.get(Block.java:600)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:614)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:614)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:614)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:614)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:614)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:614)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:614)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:614)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:614)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:614)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:614)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:614)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:614)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:614)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:614)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:614)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:614)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:614)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:614)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:614)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:614)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:614)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:614)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         
      ]
      * Reverting to original method body
      * Optimization of method <Decompressor: void decompress()> FAILED
   - Processing method <Decompressor: int getCode()>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 269 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 262
GLPKFormulation: Number of values: 216
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      ! Error processing method <Decompressor: int getCode()> [
         java.lang.RuntimeException: Invalid number of successors: 3
         \tat peggy.revert.java.JavaPEGCFGEncoder.linearizeBlocks(JavaPEGCFGEncoder.java:1023)
         \tat peggy.revert.java.JavaPEGCFGEncoder.encode(JavaPEGCFGEncoder.java:193)
         \tat peggy.optimize.java.Main.encodeCFG(Main.java:2282)
         \tat peggy.optimize.java.Main.access$26(Main.java:2277)
         \tat peggy.optimize.java.Main$50.encodeCFG(Main.java:2556)
         \tat peggy.optimize.java.Main$50.encodeCFG(Main.java:1)
         \tat peggy.optimize.SingleStageOptimizer.optimize(SingleStageOptimizer.java:157)
         \tat peggy.optimize.java.Main.optimizeAll(Main.java:875)
         \tat peggy.optimize.java.Main.optimizeClass(Main.java:704)
         \tat peggy.optimize.java.Main.main(Main.java:2881)
         
      ]
      * Reverting to original method body
      * Optimization of method <Decompressor: int getCode()> FAILED
+ Done optimizing Decompressor
+ Final results:
   - Skipped methods = 0
   - Buggy methods = 2
   - Total methods = 3
+ Fixing bytecode of method <Decompressor: void <init>(InputBuffer,OutputBuffer)>
+ Fixing bytecode of method <Decompressor: void decompress()>
+ Fixing bytecode of method <Decompressor: int getCode()>
! Cannot fetch bodies for all concrete methods [
   java.lang.RuntimeException: Local not in chain : _T92_ in <Decompressor: int getCode()>
   \tat soot.Body.validateLocal(Body.java:250)
   \tat soot.Body.validateLocals(Body.java:238)
   \tat soot.Body.validate(Body.java:201)
   \tat soot.jimple.JimpleBody.validate(JimpleBody.java:67)
   \tat soot.baf.BafBody.<init>(BafBody.java:71)
   \tat soot.baf.Baf.newBody(Baf.java:551)
   \tat peggy.optimize.java.Main.writeClassToDisk(Main.java:1663)
   \tat peggy.optimize.java.Main.optimizeAll(Main.java:932)
   \tat peggy.optimize.java.Main.optimizeClass(Main.java:704)
   \tat peggy.optimize.java.Main.main(Main.java:2881)
   
]
+ Total optimization time = 19074 milliseconds
'
END PEGGY OUTPUT
SuffixTable
Command failed
java -Xmx2000m -cp .:peggy_1.0.jar:uninlined-spec/compress/ peggy.optimize.java.Main -O2 SuffixTable -activate livsr:binop:constant -glpkPath "/glpk-5.0/examples/glpsol" -pb glpk -axioms axioms/java_arithmetic_axioms.xml:axioms/java_operator_axioms.xml:axioms/java_operator_costs.xml:axioms/java_util_axioms.xml -tmpFolder tmp
PEGGY OUTPUT:
b"+ Successfully added axiom file: axioms/java_operator_axioms.xml
+ Successfully added axiom file: axioms/java_util_axioms.xml
+ Successfully added axiom file: axioms/java_operator_costs.xml
+ Successfully added axiom file: axioms/java_arithmetic_axioms.xml
+ Loading class file SuffixTable
! !!! CRITICAL ERROR: Error loading class SuffixTable !!! [
   java.lang.RuntimeException: couldn't find class: SuffixTable (is your soot-class-path set properly?)
   \tat soot.SootResolver.bringToHierarchy(SootResolver.java:139)
   \tat soot.SootResolver.bringToSignatures(SootResolver.java:172)
   \tat soot.SootResolver.processResolveWorklist(SootResolver.java:104)
   \tat soot.SootResolver.resolveClass(SootResolver.java:89)
   \tat soot.Scene.loadClass(Scene.java:329)
   \tat soot.Scene.loadClassAndSupport(Scene.java:314)
   \tat peggy.optimize.java.Main.setup(Main.java:2598)
   \tat peggy.optimize.java.Main.main(Main.java:2870)
   
]
"
END PEGGY OUTPUT
OutputBuffer
PEGGY OUTPUT:
b'+ Successfully added axiom file: axioms/java_operator_axioms.xml
+ Successfully added axiom file: axioms/java_util_axioms.xml
+ Successfully added axiom file: axioms/java_operator_costs.xml
+ Successfully added axiom file: axioms/java_arithmetic_axioms.xml
+ Loading class file OutputBuffer
+ Optimizing class OutputBuffer
   - Processing method <OutputBuffer: void <init>(byte[])>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 14 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 14
GLPKFormulation: Number of values: 14
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <OutputBuffer: void <init>(byte[])> SUCCESSFUL
      * Optimization took 315
      * PEG2PEGTIME 232
      * PBTIME 155
      * ENGINETIME 5
      * Optimization ratio 2100/2100 = 1.0
      * PEG-based Optimization ratio 2100/2100 = 1.0
   - Done processing method <OutputBuffer: void <init>(byte[])>
   - Processing method <OutputBuffer: int getLength()>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 9 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 9
GLPKFormulation: Number of values: 9
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <OutputBuffer: int getLength()> SUCCESSFUL
      * Optimization took 162
      * PEG2PEGTIME 158
      * PBTIME 129
      * ENGINETIME 2
      * Optimization ratio 100/100 = 1.0
      * PEG-based Optimization ratio 100/100 = 1.0
   - Done processing method <OutputBuffer: int getLength()>
   - Processing method <OutputBuffer: long getCRC()>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 30 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 30
GLPKFormulation: Number of values: 30
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <OutputBuffer: long getCRC()> SUCCESSFUL
      * Optimization took 210
      * PEG2PEGTIME 188
      * PBTIME 150
      * ENGINETIME 10
      * Optimization ratio 9200/9200 = 1.0
      * PEG-based Optimization ratio 9200/9200 = 1.0
   - Done processing method <OutputBuffer: long getCRC()>
   - Processing method <OutputBuffer: void writeByte(byte)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 22 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 22
GLPKFormulation: Number of values: 21
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <OutputBuffer: void writeByte(byte)> SUCCESSFUL
      * Optimization took 191
      * PEG2PEGTIME 177
      * PBTIME 141
      * ENGINETIME 10
      * Optimization ratio 404/404 = 1.0
      * PEG-based Optimization ratio 404/404 = 1.0
   - Done processing method <OutputBuffer: void writeByte(byte)>
   - Processing method <OutputBuffer: void writebytes(byte[],int)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine reached iteration bound of 1000 after 509 milliseconds
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 877
GLPKFormulation: Number of values: 713
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <OutputBuffer: void writebytes(byte[],int)> SUCCESSFUL
      * Optimization took 4394
      * PEG2PEGTIME 4345
      * PBTIME 3797
      * ENGINETIME 509
      * Optimization ratio 5330/5330 = 1.0
      * PEG-based Optimization ratio 5330/5330 = 1.0
   - Done processing method <OutputBuffer: void writebytes(byte[],int)>
+ Done optimizing OutputBuffer
+ Final results:
   - Skipped methods = 0
   - Buggy methods = 0
   - Total methods = 5
+ Fixing bytecode of method <OutputBuffer: void <init>(byte[])>
+ Fixing bytecode of method <OutputBuffer: int getLength()>
+ Fixing bytecode of method <OutputBuffer: long getCRC()>
+ Fixing bytecode of method <OutputBuffer: void writeByte(byte)>
+ Fixing bytecode of method <OutputBuffer: void writebytes(byte[],int)>
+ Writing class back to optimized/OutputBuffer.class
+ Total optimization time = 5554 milliseconds
'
END PEGGY OUTPUT
Compressor
Command timed out
java -Xmx2000m -cp .:peggy_1.0.jar:uninlined-spec/compress/ peggy.optimize.java.Main -O2 Compressor -activate livsr:binop:constant -glpkPath "/glpk-5.0/examples/glpsol" -pb glpk -axioms axioms/java_arithmetic_axioms.xml:axioms/java_operator_axioms.xml:axioms/java_operator_costs.xml:axioms/java_util_axioms.xml -tmpFolder tmp
PEGGY OUTPUT:
b'+ Successfully added axiom file: axioms/java_operator_axioms.xml
+ Successfully added axiom file: axioms/java_util_axioms.xml
+ Successfully added axiom file: axioms/java_operator_costs.xml
+ Successfully added axiom file: axioms/java_arithmetic_axioms.xml
+ Loading class file Compressor
+ Optimizing class Compressor
   - Processing method <Compressor: void <init>(InputBuffer,OutputBuffer)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 148 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 148
GLPKFormulation: Number of values: 145
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <Compressor: void <init>(InputBuffer,OutputBuffer)> SUCCESSFUL
      * Optimization took 535
      * PEG2PEGTIME 376
      * PBTIME 241
      * ENGINETIME 53
      * Optimization ratio 22841/22841 = 1.0
      * PEG-based Optimization ratio 22841/22841 = 1.0
   - Done processing method <Compressor: void <init>(InputBuffer,OutputBuffer)>
   - Processing method <Compressor: void compress()>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine reached iteration bound of 1000 after 489 milliseconds
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 1031
GLPKFormulation: Number of values: 1115
         @ Running solver
'
END PEGGY OUTPUT
CompBase
PEGGY OUTPUT:
b'+ Successfully added axiom file: axioms/java_operator_axioms.xml
+ Successfully added axiom file: axioms/java_util_axioms.xml
+ Successfully added axiom file: axioms/java_operator_costs.xml
+ Successfully added axiom file: axioms/java_arithmetic_axioms.xml
+ Loading class file CompBase
+ Optimizing class CompBase
   - Processing method <CompBase: void <init>(InputBuffer,OutputBuffer)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 33 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 33
GLPKFormulation: Number of values: 33
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <CompBase: void <init>(InputBuffer,OutputBuffer)> SUCCESSFUL
      * Optimization took 328
      * PEG2PEGTIME 241
      * PBTIME 159
      * ENGINETIME 11
      * Optimization ratio 3500/3500 = 1.0
      * PEG-based Optimization ratio 3500/3500 = 1.0
   - Done processing method <CompBase: void <init>(InputBuffer,OutputBuffer)>
   - Processing method <CompBase: int getMaxCode()>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 12 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 12
GLPKFormulation: Number of values: 12
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <CompBase: int getMaxCode()> SUCCESSFUL
      * Optimization took 168
      * PEG2PEGTIME 162
      * PBTIME 128
      * ENGINETIME 5
      * Optimization ratio 106/106 = 1.0
      * PEG-based Optimization ratio 106/106 = 1.0
   - Done processing method <CompBase: int getMaxCode()>
+ Done optimizing CompBase
+ Final results:
   - Skipped methods = 0
   - Buggy methods = 0
   - Total methods = 2
+ Fixing bytecode of method <CompBase: void <init>(InputBuffer,OutputBuffer)>
+ Fixing bytecode of method <CompBase: int getMaxCode()>
+ Writing class back to optimized/CompBase.class
+ Total optimization time = 710 milliseconds
'
END PEGGY OUTPUT
InputBuffer
PEGGY OUTPUT:
b'+ Successfully added axiom file: axioms/java_operator_axioms.xml
+ Successfully added axiom file: axioms/java_util_axioms.xml
+ Successfully added axiom file: axioms/java_operator_costs.xml
+ Successfully added axiom file: axioms/java_arithmetic_axioms.xml
+ Loading class file InputBuffer
+ Optimizing class InputBuffer
   - Processing method <InputBuffer: void <init>(int,byte[])>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 18 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 18
GLPKFormulation: Number of values: 18
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <InputBuffer: void <init>(int,byte[])> SUCCESSFUL
      * Optimization took 324
      * PEG2PEGTIME 240
      * PBTIME 160
      * ENGINETIME 7
      * Optimization ratio 2200/2200 = 1.0
      * PEG-based Optimization ratio 2200/2200 = 1.0
   - Done processing method <InputBuffer: void <init>(int,byte[])>
   - Processing method <InputBuffer: int readByte()>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 37 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 37
GLPKFormulation: Number of values: 34
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <InputBuffer: int readByte()> SUCCESSFUL
      * Optimization took 229
      * PEG2PEGTIME 200
      * PBTIME 153
      * ENGINETIME 16
      * Optimization ratio 617/617 = 1.0
      * PEG-based Optimization ratio 617/617 = 1.0
   - Done processing method <InputBuffer: int readByte()>
   - Processing method <InputBuffer: int readBytes(byte[],int)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine reached iteration bound of 1000 after 486 milliseconds
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 661
GLPKFormulation: Number of values: 640
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <InputBuffer: int readBytes(byte[],int)> SUCCESSFUL
      * Optimization took 2795
      * PEG2PEGTIME 2736
      * PBTIME 2225
      * ENGINETIME 486
      * Optimization ratio 9575/9575 = 1.0
      * PEG-based Optimization ratio 9575/9575 = 1.0
   - Done processing method <InputBuffer: int readBytes(byte[],int)>
+ Done optimizing InputBuffer
+ Final results:
   - Skipped methods = 0
   - Buggy methods = 0
   - Total methods = 3
+ Fixing bytecode of method <InputBuffer: void <init>(int,byte[])>
+ Fixing bytecode of method <InputBuffer: int readByte()>
+ Fixing bytecode of method <InputBuffer: int readBytes(byte[],int)>
+ Writing class back to optimized/InputBuffer.class
+ Total optimization time = 3618 milliseconds
'
END PEGGY OUTPUT
CodeTable
PEGGY OUTPUT:
b'+ Successfully added axiom file: axioms/java_operator_axioms.xml
+ Successfully added axiom file: axioms/java_util_axioms.xml
+ Successfully added axiom file: axioms/java_operator_costs.xml
+ Successfully added axiom file: axioms/java_arithmetic_axioms.xml
+ Loading class file CodeTable
+ Optimizing class CodeTable
   - Processing method <CodeTable: void <init>()>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 18 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 18
GLPKFormulation: Number of values: 18
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <CodeTable: void <init>()> SUCCESSFUL
      * Optimization took 323
      * PEG2PEGTIME 240
      * PBTIME 162
      * ENGINETIME 6
      * Optimization ratio 3100/3100 = 1.0
      * PEG-based Optimization ratio 3100/3100 = 1.0
   - Done processing method <CodeTable: void <init>()>
   - Processing method <CodeTable: int of(int)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 16 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 16
GLPKFormulation: Number of values: 16
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <CodeTable: int of(int)> SUCCESSFUL
      * Optimization took 177
      * PEG2PEGTIME 169
      * PBTIME 136
      * ENGINETIME 5
      * Optimization ratio 204/204 = 1.0
      * PEG-based Optimization ratio 204/204 = 1.0
   - Done processing method <CodeTable: int of(int)>
   - Processing method <CodeTable: void set(int,int)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 16 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 16
GLPKFormulation: Number of values: 16
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <CodeTable: void set(int,int)> SUCCESSFUL
      * Optimization took 196
      * PEG2PEGTIME 183
      * PBTIME 136
      * ENGINETIME 4
      * Optimization ratio 220/220 = 1.0
      * PEG-based Optimization ratio 220/220 = 1.0
   - Done processing method <CodeTable: void set(int,int)>
   - Processing method <CodeTable: void clear(int)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine reached iteration bound of 1000 after 550 milliseconds
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 1163
GLPKFormulation: Number of values: 854
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <CodeTable: void clear(int)> SUCCESSFUL
      * Optimization took 3368
      * PEG2PEGTIME 3331
      * PBTIME 2737
      * ENGINETIME 550
      * Optimization ratio 2290/2290 = 1.0
      * PEG-based Optimization ratio 2290/2290 = 1.0
   - Done processing method <CodeTable: void clear(int)>
+ Done optimizing CodeTable
+ Final results:
   - Skipped methods = 0
   - Buggy methods = 0
   - Total methods = 4
+ Fixing bytecode of method <CodeTable: void <init>()>
+ Fixing bytecode of method <CodeTable: int of(int)>
+ Fixing bytecode of method <CodeTable: void set(int,int)>
+ Fixing bytecode of method <CodeTable: void clear(int)>
+ Writing class back to optimized/CodeTable.class
+ Total optimization time = 4305 milliseconds
'
END PEGGY OUTPUT
DeStack
Command failed
java -Xmx2000m -cp .:peggy_1.0.jar:uninlined-spec/compress/ peggy.optimize.java.Main -O2 DeStack -activate livsr:binop:constant -glpkPath "/glpk-5.0/examples/glpsol" -pb glpk -axioms axioms/java_arithmetic_axioms.xml:axioms/java_operator_axioms.xml:axioms/java_operator_costs.xml:axioms/java_util_axioms.xml -tmpFolder tmp
PEGGY OUTPUT:
b"+ Successfully added axiom file: axioms/java_operator_axioms.xml
+ Successfully added axiom file: axioms/java_util_axioms.xml
+ Successfully added axiom file: axioms/java_operator_costs.xml
+ Successfully added axiom file: axioms/java_arithmetic_axioms.xml
+ Loading class file DeStack
! !!! CRITICAL ERROR: Error loading class DeStack !!! [
   java.lang.RuntimeException: couldn't find class: DeStack (is your soot-class-path set properly?)
   \tat soot.SootResolver.bringToHierarchy(SootResolver.java:139)
   \tat soot.SootResolver.bringToSignatures(SootResolver.java:172)
   \tat soot.SootResolver.processResolveWorklist(SootResolver.java:104)
   \tat soot.SootResolver.resolveClass(SootResolver.java:89)
   \tat soot.Scene.loadClass(Scene.java:329)
   \tat soot.Scene.loadClassAndSupport(Scene.java:314)
   \tat peggy.optimize.java.Main.setup(Main.java:2598)
   \tat peggy.optimize.java.Main.main(Main.java:2870)
   
]
"
END PEGGY OUTPUT
HashTable
Command failed
java -Xmx2000m -cp .:peggy_1.0.jar:uninlined-spec/compress/ peggy.optimize.java.Main -O2 HashTable -activate livsr:binop:constant -glpkPath "/glpk-5.0/examples/glpsol" -pb glpk -axioms axioms/java_arithmetic_axioms.xml:axioms/java_operator_axioms.xml:axioms/java_operator_costs.xml:axioms/java_util_axioms.xml -tmpFolder tmp
PEGGY OUTPUT:
b"+ Successfully added axiom file: axioms/java_operator_axioms.xml
+ Successfully added axiom file: axioms/java_util_axioms.xml
+ Successfully added axiom file: axioms/java_operator_costs.xml
+ Successfully added axiom file: axioms/java_arithmetic_axioms.xml
+ Loading class file HashTable
! !!! CRITICAL ERROR: Error loading class HashTable !!! [
   java.lang.RuntimeException: couldn't find class: HashTable (is your soot-class-path set properly?)
   \tat soot.SootResolver.bringToHierarchy(SootResolver.java:139)
   \tat soot.SootResolver.bringToSignatures(SootResolver.java:172)
   \tat soot.SootResolver.processResolveWorklist(SootResolver.java:104)
   \tat soot.SootResolver.resolveClass(SootResolver.java:89)
   \tat soot.Scene.loadClass(Scene.java:329)
   \tat soot.Scene.loadClassAndSupport(Scene.java:314)
   \tat peggy.optimize.java.Main.setup(Main.java:2598)
   \tat peggy.optimize.java.Main.main(Main.java:2870)
   
]
"
END PEGGY OUTPUT
Source
Command failed
java -Xmx2000m -cp .:peggy_1.0.jar:uninlined-spec/compress/ peggy.optimize.java.Main -O2 Source -activate livsr:binop:constant -glpkPath "/glpk-5.0/examples/glpsol" -pb glpk -axioms axioms/java_arithmetic_axioms.xml:axioms/java_operator_axioms.xml:axioms/java_operator_costs.xml:axioms/java_util_axioms.xml -tmpFolder tmp
PEGGY OUTPUT:
b"+ Successfully added axiom file: axioms/java_operator_axioms.xml
+ Successfully added axiom file: axioms/java_util_axioms.xml
+ Successfully added axiom file: axioms/java_operator_costs.xml
+ Successfully added axiom file: axioms/java_arithmetic_axioms.xml
+ Loading class file Source
! !!! CRITICAL ERROR: Error loading class Source !!! [
   java.lang.RuntimeException: couldn't find class: Source (is your soot-class-path set properly?)
   \tat soot.SootResolver.bringToHierarchy(SootResolver.java:139)
   \tat soot.SootResolver.bringToSignatures(SootResolver.java:172)
   \tat soot.SootResolver.processResolveWorklist(SootResolver.java:104)
   \tat soot.SootResolver.resolveClass(SootResolver.java:89)
   \tat soot.Scene.loadClass(Scene.java:329)
   \tat soot.Scene.loadClassAndSupport(Scene.java:314)
   \tat peggy.optimize.java.Main.setup(Main.java:2598)
   \tat peggy.optimize.java.Main.main(Main.java:2870)
   
]
"
END PEGGY OUTPUT
Harness
PEGGY OUTPUT:
b'+ Successfully added axiom file: axioms/java_operator_axioms.xml
+ Successfully added axiom file: axioms/java_util_axioms.xml
+ Successfully added axiom file: axioms/java_operator_costs.xml
+ Successfully added axiom file: axioms/java_arithmetic_axioms.xml
+ Loading class file Harness
+ Optimizing class Harness
   - Processing method <Harness: void <init>()>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 10 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 10
GLPKFormulation: Number of values: 10
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <Harness: void <init>()> SUCCESSFUL
      * Optimization took 310
      * PEG2PEGTIME 228
      * PBTIME 155
      * ENGINETIME 5
      * Optimization ratio 2000/2000 = 1.0
      * PEG-based Optimization ratio 2000/2000 = 1.0
   - Done processing method <Harness: void <init>()>
   - Processing method <Harness: void runCompress(int)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine reached iteration bound of 1000 after 460 milliseconds
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 568
GLPKFormulation: Number of values: 942
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <Harness: void runCompress(int)> SUCCESSFUL
      * Optimization took 1688
      * PEG2PEGTIME 1534
      * PBTIME 1023
      * ENGINETIME 460
      * Optimization ratio 8628694/8628694 = 1.0
      * PEG-based Optimization ratio 8628694/8628694 = 1.0
   - Done processing method <Harness: void runCompress(int)>
   - Processing method <Harness: long inst_main(int)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 19 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 19
GLPKFormulation: Number of values: 19
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <Harness: long inst_main(int)> SUCCESSFUL
      * Optimization took 164
      * PEG2PEGTIME 159
      * PBTIME 136
      * ENGINETIME 1
      * Optimization ratio 7004/7004 = 1.0
      * PEG-based Optimization ratio 7004/7004 = 1.0
   - Done processing method <Harness: long inst_main(int)>
   - Processing method <Harness: void prepareBuffers()>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine reached iteration bound of 1000 after 238 milliseconds
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 289
GLPKFormulation: Number of values: 779
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <Harness: void prepareBuffers()> SUCCESSFUL
      * Optimization took 625
      * PEG2PEGTIME 577
      * PBTIME 321
      * ENGINETIME 238
      * Optimization ratio 161990/161990 = 1.0
      * PEG-based Optimization ratio 161990/161990 = 1.0
   - Done processing method <Harness: void prepareBuffers()>
   - Processing method <Harness: void <clinit>()>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 62 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 62
GLPKFormulation: Number of values: 61
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <Harness: void <clinit>()> SUCCESSFUL
      * Optimization took 190
      * PEG2PEGTIME 175
      * PBTIME 158
      * ENGINETIME 2
      * Optimization ratio 2360/2360 = 1.0
      * PEG-based Optimization ratio 2360/2360 = 1.0
   - Done processing method <Harness: void <clinit>()>
+ Done optimizing Harness
+ Final results:
   - Skipped methods = 0
   - Buggy methods = 0
   - Total methods = 5
+ Fixing bytecode of method <Harness: void <init>()>
+ Fixing bytecode of method <Harness: void runCompress(int)>
+ Fixing bytecode of method <Harness: long inst_main(int)>
+ Fixing bytecode of method <Harness: void prepareBuffers()>
+ Fixing bytecode of method <Harness: void <clinit>()>
+ Writing class back to optimized/Harness.class
+ Total optimization time = 3384 milliseconds
'
END PEGGY OUTPUT
BENCHMARKING inlined-spec/compress/
Decompressor
PEGGY OUTPUT:
b'+ Successfully added axiom file: axioms/java_operator_axioms.xml
+ Successfully added axiom file: axioms/java_util_axioms.xml
+ Successfully added axiom file: axioms/java_operator_costs.xml
+ Successfully added axiom file: axioms/java_arithmetic_axioms.xml
+ Loading class file Decompressor
+ Optimizing class Decompressor
   - Processing method <Decompressor: void <init>(InputBuffer,OutputBuffer)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine reached iteration bound of 1000 after 464 milliseconds
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 1123
GLPKFormulation: Number of values: 952
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <Decompressor: void <init>(InputBuffer,OutputBuffer)> SUCCESSFUL
      * Optimization took 8538
      * PEG2PEGTIME 8278
      * PBTIME 7715
      * ENGINETIME 465
      * Optimization ratio 49987/49993 = 0.9998799831976477
      * PEG-based Optimization ratio 49987/49993 = 0.9998799831976477
   - Done processing method <Decompressor: void <init>(InputBuffer,OutputBuffer)>
   - Processing method <Decompressor: void decompress()>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine reached iteration bound of 1000 after 117 milliseconds
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 1179
GLPKFormulation: Number of values: 1092
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      ! Error processing method <Decompressor: void decompress()> [
         java.lang.StackOverflowError
         \tat java.util.HashSet.add(HashSet.java:217)
         \tat eqsat.revert.Block$8.get(Block.java:597)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:614)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:614)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:614)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:614)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:614)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:614)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:614)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:614)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:614)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:614)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:614)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:614)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:614)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:614)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:614)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:614)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:614)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:614)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:614)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         \tat eqsat.revert.Block$8.get(Block.java:601)
         
      ]
      * Reverting to original method body
      * Optimization of method <Decompressor: void decompress()> FAILED
   - Processing method <Decompressor: int getCode()>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine reached iteration bound of 1000 after 190 milliseconds
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 633
GLPKFormulation: Number of values: 832
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      ! Error processing method <Decompressor: int getCode()> [
         java.lang.IllegalArgumentException
         \tat eqsat.revert.Block.processVolatility(Block.java:1113)
         \tat eqsat.revert.Block.processVolatility(Block.java:1096)
         \tat eqsat.revert.Block.serialize(Block.java:1228)
         \tat eqsat.revert.FallBlock.process(FallBlock.java:34)
         \tat eqsat.revert.FallBlock.addToCFG(FallBlock.java:29)
         \tat eqsat.revert.BranchBlock$8.addToCFG(BranchBlock.java:311)
         \tat eqsat.revert.BranchBlock.addToCFG(BranchBlock.java:94)
         \tat eqsat.revert.Block$25.addToCFG(Block.java:1338)
         \tat eqsat.revert.Block$26.addToCFG(Block.java:1351)
         \tat eqsat.revert.Block$26.addToCFG(Block.java:1352)
         \tat eqsat.revert.Block$26.addToCFG(Block.java:1352)
         \tat eqsat.revert.FallBlock$1.addToCFG(FallBlock.java:40)
         \tat eqsat.revert.FallBlock.addToCFG(FallBlock.java:30)
         \tat eqsat.revert.BranchBlock$8.addToCFG(BranchBlock.java:311)
         \tat eqsat.revert.BranchBlock.addToCFG(BranchBlock.java:94)
         \tat eqsat.revert.Block$25.addToCFG(Block.java:1338)
         \tat eqsat.revert.Block$26.addToCFG(Block.java:1351)
         \tat eqsat.revert.FallBlock$1.addToCFG(FallBlock.java:40)
         \tat eqsat.revert.FallBlock.addToCFG(FallBlock.java:30)
         \tat eqsat.revert.CFGReverter.<init>(CFGReverter.java:37)
         \tat peggy.optimize.SingleStageOptimizer.optimize(SingleStageOptimizer.java:104)
         \tat peggy.optimize.java.Main.optimizeAll(Main.java:875)
         \tat peggy.optimize.java.Main.optimizeClass(Main.java:704)
         \tat peggy.optimize.java.Main.main(Main.java:2881)
         
      ]
      * Reverting to original method body
      * Optimization of method <Decompressor: int getCode()> FAILED
+ Done optimizing Decompressor
+ Final results:
   - Skipped methods = 0
   - Buggy methods = 2
   - Total methods = 3
+ Fixing bytecode of method <Decompressor: void <init>(InputBuffer,OutputBuffer)>
+ Fixing bytecode of method <Decompressor: void decompress()>
+ Fixing bytecode of method <Decompressor: int getCode()>
+ Writing class back to optimized/Decompressor.class
+ Total optimization time = 31048 milliseconds
'
END PEGGY OUTPUT
SuffixTable
Command failed
java -Xmx2000m -cp .:peggy_1.0.jar:inlined-spec/compress/ peggy.optimize.java.Main -O2 SuffixTable -activate livsr:binop:constant -glpkPath "/glpk-5.0/examples/glpsol" -pb glpk -axioms axioms/java_arithmetic_axioms.xml:axioms/java_operator_axioms.xml:axioms/java_operator_costs.xml:axioms/java_util_axioms.xml -tmpFolder tmp
PEGGY OUTPUT:
b"+ Successfully added axiom file: axioms/java_operator_axioms.xml
+ Successfully added axiom file: axioms/java_util_axioms.xml
+ Successfully added axiom file: axioms/java_operator_costs.xml
+ Successfully added axiom file: axioms/java_arithmetic_axioms.xml
+ Loading class file SuffixTable
! !!! CRITICAL ERROR: Error loading class SuffixTable !!! [
   java.lang.RuntimeException: couldn't find class: SuffixTable (is your soot-class-path set properly?)
   \tat soot.SootResolver.bringToHierarchy(SootResolver.java:139)
   \tat soot.SootResolver.bringToSignatures(SootResolver.java:172)
   \tat soot.SootResolver.processResolveWorklist(SootResolver.java:104)
   \tat soot.SootResolver.resolveClass(SootResolver.java:89)
   \tat soot.Scene.loadClass(Scene.java:329)
   \tat soot.Scene.loadClassAndSupport(Scene.java:314)
   \tat peggy.optimize.java.Main.setup(Main.java:2598)
   \tat peggy.optimize.java.Main.main(Main.java:2870)
   
]
"
END PEGGY OUTPUT
OutputBuffer
PEGGY OUTPUT:
b'+ Successfully added axiom file: axioms/java_operator_axioms.xml
+ Successfully added axiom file: axioms/java_util_axioms.xml
+ Successfully added axiom file: axioms/java_operator_costs.xml
+ Successfully added axiom file: axioms/java_arithmetic_axioms.xml
+ Loading class file OutputBuffer
+ Optimizing class OutputBuffer
   - Processing method <OutputBuffer: void <init>(byte[])>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 14 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 14
GLPKFormulation: Number of values: 14
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <OutputBuffer: void <init>(byte[])> SUCCESSFUL
      * Optimization took 323
      * PEG2PEGTIME 238
      * PBTIME 158
      * ENGINETIME 6
      * Optimization ratio 2100/2100 = 1.0
      * PEG-based Optimization ratio 2100/2100 = 1.0
   - Done processing method <OutputBuffer: void <init>(byte[])>
   - Processing method <OutputBuffer: int getLength()>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 9 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 9
GLPKFormulation: Number of values: 9
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <OutputBuffer: int getLength()> SUCCESSFUL
      * Optimization took 166
      * PEG2PEGTIME 161
      * PBTIME 131
      * ENGINETIME 2
      * Optimization ratio 100/100 = 1.0
      * PEG-based Optimization ratio 100/100 = 1.0
   - Done processing method <OutputBuffer: int getLength()>
   - Processing method <OutputBuffer: long getCRC()>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 30 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 30
GLPKFormulation: Number of values: 30
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <OutputBuffer: long getCRC()> SUCCESSFUL
      * Optimization took 220
      * PEG2PEGTIME 200
      * PBTIME 151
      * ENGINETIME 7
      * Optimization ratio 9200/9200 = 1.0
      * PEG-based Optimization ratio 9200/9200 = 1.0
   - Done processing method <OutputBuffer: long getCRC()>
   - Processing method <OutputBuffer: void writeByte(byte)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 22 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 22
GLPKFormulation: Number of values: 21
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <OutputBuffer: void writeByte(byte)> SUCCESSFUL
      * Optimization took 202
      * PEG2PEGTIME 190
      * PBTIME 142
      * ENGINETIME 10
      * Optimization ratio 404/404 = 1.0
      * PEG-based Optimization ratio 404/404 = 1.0
   - Done processing method <OutputBuffer: void writeByte(byte)>
   - Processing method <OutputBuffer: void writebytes(byte[],int)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine reached iteration bound of 1000 after 520 milliseconds
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 885
GLPKFormulation: Number of values: 728
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <OutputBuffer: void writebytes(byte[],int)> SUCCESSFUL
      * Optimization took 7195
      * PEG2PEGTIME 7144
      * PBTIME 6597
      * ENGINETIME 520
      * Optimization ratio 5330/5330 = 1.0
      * PEG-based Optimization ratio 5330/5330 = 1.0
   - Done processing method <OutputBuffer: void writebytes(byte[],int)>
+ Done optimizing OutputBuffer
+ Final results:
   - Skipped methods = 0
   - Buggy methods = 0
   - Total methods = 5
+ Fixing bytecode of method <OutputBuffer: void <init>(byte[])>
+ Fixing bytecode of method <OutputBuffer: int getLength()>
+ Fixing bytecode of method <OutputBuffer: long getCRC()>
+ Fixing bytecode of method <OutputBuffer: void writeByte(byte)>
+ Fixing bytecode of method <OutputBuffer: void writebytes(byte[],int)>
+ Writing class back to optimized/OutputBuffer.class
+ Total optimization time = 8390 milliseconds
'
END PEGGY OUTPUT
CodeTable
PEGGY OUTPUT:
b'+ Successfully added axiom file: axioms/java_operator_axioms.xml
+ Successfully added axiom file: axioms/java_util_axioms.xml
+ Successfully added axiom file: axioms/java_operator_costs.xml
+ Successfully added axiom file: axioms/java_arithmetic_axioms.xml
+ Loading class file CodeTable
+ Optimizing class CodeTable
   - Processing method <CodeTable: void <init>()>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 18 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 18
GLPKFormulation: Number of values: 18
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <CodeTable: void <init>()> SUCCESSFUL
      * Optimization took 319
      * PEG2PEGTIME 237
      * PBTIME 159
      * ENGINETIME 6
      * Optimization ratio 3100/3100 = 1.0
      * PEG-based Optimization ratio 3100/3100 = 1.0
   - Done processing method <CodeTable: void <init>()>
   - Processing method <CodeTable: int of(int)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 16 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 16
GLPKFormulation: Number of values: 16
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <CodeTable: int of(int)> SUCCESSFUL
      * Optimization took 177
      * PEG2PEGTIME 168
      * PBTIME 135
      * ENGINETIME 6
      * Optimization ratio 204/204 = 1.0
      * PEG-based Optimization ratio 204/204 = 1.0
   - Done processing method <CodeTable: int of(int)>
   - Processing method <CodeTable: void set(int,int)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 16 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 16
GLPKFormulation: Number of values: 16
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <CodeTable: void set(int,int)> SUCCESSFUL
      * Optimization took 188
      * PEG2PEGTIME 176
      * PBTIME 134
      * ENGINETIME 4
      * Optimization ratio 220/220 = 1.0
      * PEG-based Optimization ratio 220/220 = 1.0
   - Done processing method <CodeTable: void set(int,int)>
   - Processing method <CodeTable: void clear(int)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine reached iteration bound of 1000 after 537 milliseconds
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 1161
GLPKFormulation: Number of values: 852
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <CodeTable: void clear(int)> SUCCESSFUL
      * Optimization took 2453
      * PEG2PEGTIME 2415
      * PBTIME 1836
      * ENGINETIME 538
      * Optimization ratio 2290/2290 = 1.0
      * PEG-based Optimization ratio 2290/2290 = 1.0
   - Done processing method <CodeTable: void clear(int)>
+ Done optimizing CodeTable
+ Final results:
   - Skipped methods = 0
   - Buggy methods = 0
   - Total methods = 4
+ Fixing bytecode of method <CodeTable: void <init>()>
+ Fixing bytecode of method <CodeTable: int of(int)>
+ Fixing bytecode of method <CodeTable: void set(int,int)>
+ Fixing bytecode of method <CodeTable: void clear(int)>
+ Writing class back to optimized/CodeTable.class
+ Total optimization time = 3377 milliseconds
'
END PEGGY OUTPUT
InputBuffer
PEGGY OUTPUT:
b'+ Successfully added axiom file: axioms/java_operator_axioms.xml
+ Successfully added axiom file: axioms/java_util_axioms.xml
+ Successfully added axiom file: axioms/java_operator_costs.xml
+ Successfully added axiom file: axioms/java_arithmetic_axioms.xml
+ Loading class file InputBuffer
+ Optimizing class InputBuffer
   - Processing method <InputBuffer: void <init>(int,byte[])>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 18 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 18
GLPKFormulation: Number of values: 18
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <InputBuffer: void <init>(int,byte[])> SUCCESSFUL
      * Optimization took 325
      * PEG2PEGTIME 240
      * PBTIME 160
      * ENGINETIME 7
      * Optimization ratio 2200/2200 = 1.0
      * PEG-based Optimization ratio 2200/2200 = 1.0
   - Done processing method <InputBuffer: void <init>(int,byte[])>
   - Processing method <InputBuffer: int readByte()>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 37 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 37
GLPKFormulation: Number of values: 34
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <InputBuffer: int readByte()> SUCCESSFUL
      * Optimization took 232
      * PEG2PEGTIME 204
      * PBTIME 153
      * ENGINETIME 17
      * Optimization ratio 617/617 = 1.0
      * PEG-based Optimization ratio 617/617 = 1.0
   - Done processing method <InputBuffer: int readByte()>
   - Processing method <InputBuffer: int readBytes(byte[],int)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine reached iteration bound of 1000 after 499 milliseconds
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 671
GLPKFormulation: Number of values: 629
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <InputBuffer: int readBytes(byte[],int)> SUCCESSFUL
      * Optimization took 2321
      * PEG2PEGTIME 2255
      * PBTIME 1732
      * ENGINETIME 499
      * Optimization ratio 9575/9575 = 1.0
      * PEG-based Optimization ratio 9575/9575 = 1.0
   - Done processing method <InputBuffer: int readBytes(byte[],int)>
+ Done optimizing InputBuffer
+ Final results:
   - Skipped methods = 0
   - Buggy methods = 0
   - Total methods = 3
+ Fixing bytecode of method <InputBuffer: void <init>(int,byte[])>
+ Fixing bytecode of method <InputBuffer: int readByte()>
+ Fixing bytecode of method <InputBuffer: int readBytes(byte[],int)>
+ Writing class back to optimized/InputBuffer.class
+ Total optimization time = 3130 milliseconds
'
END PEGGY OUTPUT
Compressor
Command timed out
java -Xmx2000m -cp .:peggy_1.0.jar:inlined-spec/compress/ peggy.optimize.java.Main -O2 Compressor -activate livsr:binop:constant -glpkPath "/glpk-5.0/examples/glpsol" -pb glpk -axioms axioms/java_arithmetic_axioms.xml:axioms/java_operator_axioms.xml:axioms/java_operator_costs.xml:axioms/java_util_axioms.xml -tmpFolder tmp
PEGGY OUTPUT:
b'+ Successfully added axiom file: axioms/java_operator_axioms.xml
+ Successfully added axiom file: axioms/java_util_axioms.xml
+ Successfully added axiom file: axioms/java_operator_costs.xml
+ Successfully added axiom file: axioms/java_arithmetic_axioms.xml
+ Loading class file Compressor
+ Optimizing class Compressor
   - Processing method <Compressor: void <init>(InputBuffer,OutputBuffer)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 188 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 185
GLPKFormulation: Number of values: 179
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <Compressor: void <init>(InputBuffer,OutputBuffer)> SUCCESSFUL
      * Optimization took 572
      * PEG2PEGTIME 402
      * PBTIME 244
      * ENGINETIME 75
      * Optimization ratio 12453/12459 = 0.9995184204189742
      * PEG-based Optimization ratio 12453/12459 = 0.9995184204189742
   - Done processing method <Compressor: void <init>(InputBuffer,OutputBuffer)>
   - Processing method <Compressor: void compress()>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine reached iteration bound of 1000 after 236 milliseconds
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 1696
GLPKFormulation: Number of values: 1632
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
'
END PEGGY OUTPUT
CompBase
PEGGY OUTPUT:
b'+ Successfully added axiom file: axioms/java_operator_axioms.xml
+ Successfully added axiom file: axioms/java_util_axioms.xml
+ Successfully added axiom file: axioms/java_operator_costs.xml
+ Successfully added axiom file: axioms/java_arithmetic_axioms.xml
+ Loading class file CompBase
+ Optimizing class CompBase
   - Processing method <CompBase: void <init>(InputBuffer,OutputBuffer)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 33 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 33
GLPKFormulation: Number of values: 33
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <CompBase: void <init>(InputBuffer,OutputBuffer)> SUCCESSFUL
      * Optimization took 338
      * PEG2PEGTIME 251
      * PBTIME 168
      * ENGINETIME 11
      * Optimization ratio 3500/3500 = 1.0
      * PEG-based Optimization ratio 3500/3500 = 1.0
   - Done processing method <CompBase: void <init>(InputBuffer,OutputBuffer)>
   - Processing method <CompBase: int getMaxCode()>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 12 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 12
GLPKFormulation: Number of values: 12
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <CompBase: int getMaxCode()> SUCCESSFUL
      * Optimization took 166
      * PEG2PEGTIME 160
      * PBTIME 129
      * ENGINETIME 4
      * Optimization ratio 106/106 = 1.0
      * PEG-based Optimization ratio 106/106 = 1.0
   - Done processing method <CompBase: int getMaxCode()>
+ Done optimizing CompBase
+ Final results:
   - Skipped methods = 0
   - Buggy methods = 0
   - Total methods = 2
+ Fixing bytecode of method <CompBase: void <init>(InputBuffer,OutputBuffer)>
+ Fixing bytecode of method <CompBase: int getMaxCode()>
+ Writing class back to optimized/CompBase.class
+ Total optimization time = 716 milliseconds
'
END PEGGY OUTPUT
DeStack
Command failed
java -Xmx2000m -cp .:peggy_1.0.jar:inlined-spec/compress/ peggy.optimize.java.Main -O2 DeStack -activate livsr:binop:constant -glpkPath "/glpk-5.0/examples/glpsol" -pb glpk -axioms axioms/java_arithmetic_axioms.xml:axioms/java_operator_axioms.xml:axioms/java_operator_costs.xml:axioms/java_util_axioms.xml -tmpFolder tmp
PEGGY OUTPUT:
b"+ Successfully added axiom file: axioms/java_operator_axioms.xml
+ Successfully added axiom file: axioms/java_util_axioms.xml
+ Successfully added axiom file: axioms/java_operator_costs.xml
+ Successfully added axiom file: axioms/java_arithmetic_axioms.xml
+ Loading class file DeStack
! !!! CRITICAL ERROR: Error loading class DeStack !!! [
   java.lang.RuntimeException: couldn't find class: DeStack (is your soot-class-path set properly?)
   \tat soot.SootResolver.bringToHierarchy(SootResolver.java:139)
   \tat soot.SootResolver.bringToSignatures(SootResolver.java:172)
   \tat soot.SootResolver.processResolveWorklist(SootResolver.java:104)
   \tat soot.SootResolver.resolveClass(SootResolver.java:89)
   \tat soot.Scene.loadClass(Scene.java:329)
   \tat soot.Scene.loadClassAndSupport(Scene.java:314)
   \tat peggy.optimize.java.Main.setup(Main.java:2598)
   \tat peggy.optimize.java.Main.main(Main.java:2870)
   
]
"
END PEGGY OUTPUT
HashTable
Command failed
java -Xmx2000m -cp .:peggy_1.0.jar:inlined-spec/compress/ peggy.optimize.java.Main -O2 HashTable -activate livsr:binop:constant -glpkPath "/glpk-5.0/examples/glpsol" -pb glpk -axioms axioms/java_arithmetic_axioms.xml:axioms/java_operator_axioms.xml:axioms/java_operator_costs.xml:axioms/java_util_axioms.xml -tmpFolder tmp
PEGGY OUTPUT:
b"+ Successfully added axiom file: axioms/java_operator_axioms.xml
+ Successfully added axiom file: axioms/java_util_axioms.xml
+ Successfully added axiom file: axioms/java_operator_costs.xml
+ Successfully added axiom file: axioms/java_arithmetic_axioms.xml
+ Loading class file HashTable
! !!! CRITICAL ERROR: Error loading class HashTable !!! [
   java.lang.RuntimeException: couldn't find class: HashTable (is your soot-class-path set properly?)
   \tat soot.SootResolver.bringToHierarchy(SootResolver.java:139)
   \tat soot.SootResolver.bringToSignatures(SootResolver.java:172)
   \tat soot.SootResolver.processResolveWorklist(SootResolver.java:104)
   \tat soot.SootResolver.resolveClass(SootResolver.java:89)
   \tat soot.Scene.loadClass(Scene.java:329)
   \tat soot.Scene.loadClassAndSupport(Scene.java:314)
   \tat peggy.optimize.java.Main.setup(Main.java:2598)
   \tat peggy.optimize.java.Main.main(Main.java:2870)
   
]
"
END PEGGY OUTPUT
Source
Command failed
java -Xmx2000m -cp .:peggy_1.0.jar:inlined-spec/compress/ peggy.optimize.java.Main -O2 Source -activate livsr:binop:constant -glpkPath "/glpk-5.0/examples/glpsol" -pb glpk -axioms axioms/java_arithmetic_axioms.xml:axioms/java_operator_axioms.xml:axioms/java_operator_costs.xml:axioms/java_util_axioms.xml -tmpFolder tmp
PEGGY OUTPUT:
b"+ Successfully added axiom file: axioms/java_operator_axioms.xml
+ Successfully added axiom file: axioms/java_util_axioms.xml
+ Successfully added axiom file: axioms/java_operator_costs.xml
+ Successfully added axiom file: axioms/java_arithmetic_axioms.xml
+ Loading class file Source
! !!! CRITICAL ERROR: Error loading class Source !!! [
   java.lang.RuntimeException: couldn't find class: Source (is your soot-class-path set properly?)
   \tat soot.SootResolver.bringToHierarchy(SootResolver.java:139)
   \tat soot.SootResolver.bringToSignatures(SootResolver.java:172)
   \tat soot.SootResolver.processResolveWorklist(SootResolver.java:104)
   \tat soot.SootResolver.resolveClass(SootResolver.java:89)
   \tat soot.Scene.loadClass(Scene.java:329)
   \tat soot.Scene.loadClassAndSupport(Scene.java:314)
   \tat peggy.optimize.java.Main.setup(Main.java:2598)
   \tat peggy.optimize.java.Main.main(Main.java:2870)
   
]
"
END PEGGY OUTPUT
Harness
Command timed out
java -Xmx2000m -cp .:peggy_1.0.jar:inlined-spec/compress/ peggy.optimize.java.Main -O2 Harness -activate livsr:binop:constant -glpkPath "/glpk-5.0/examples/glpsol" -pb glpk -axioms axioms/java_arithmetic_axioms.xml:axioms/java_operator_axioms.xml:axioms/java_operator_costs.xml:axioms/java_util_axioms.xml -tmpFolder tmp
PEGGY OUTPUT:
b'+ Successfully added axiom file: axioms/java_operator_axioms.xml
+ Successfully added axiom file: axioms/java_util_axioms.xml
+ Successfully added axiom file: axioms/java_operator_costs.xml
+ Successfully added axiom file: axioms/java_arithmetic_axioms.xml
+ Loading class file Harness
+ Optimizing class Harness
   - Processing method <Harness: void <init>()>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine saturated in 10 iterations
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 10
GLPKFormulation: Number of values: 10
         @ Running solver
         @ GLPK solver returned nonempty result
      * Building reversion graph
      * Building revert CFG
      * Building output CFG
      * Encoding output CFG
      * Optimization completed
      * Optimization of method <Harness: void <init>()> SUCCESSFUL
      * Optimization took 310
      * PEG2PEGTIME 229
      * PBTIME 155
      * ENGINETIME 4
      * Optimization ratio 2000/2000 = 1.0
      * PEG-based Optimization ratio 2000/2000 = 1.0
   - Done processing method <Harness: void <init>()>
   - Processing method <Harness: void runCompress(int)>
      * Building original PEG
      * Setting up engine
         @ Activating analysis: livsr
         @ Activating analysis: binop
         @ Activating analysis: constant
      * Running engine
      * Engine reached iteration bound of 1000 after 231 milliseconds
      * Building optimal PEG
      * Begin GLPK solving
         @ Writing formulation
GLPKFormulation: Number of nodes: 5170
GLPKFormulation: Number of values: 5084
         @ Running solver
'
END PEGGY OUTPUT
